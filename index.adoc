= H446/03
Callum Tarttelin, 1164, 51617
// Settings:
:pdf-style:
:experimental:
:reproducible:
:icons: font
:listing-caption: Listing
:sectnums:
:toc:
:toclevels: 3
ifdef::backend-pdf[]
:title-logo-image: image:other-pictures/bowling_ball.png[pdfwidth=4.25in,align=center]

:source-highlighter: rouge
endif::[]
// URIs:



[#Research]
== Research
The client currently has a bowling league with an older website. 
The purpose of this project will be to replace this website with a website easier to use.

=== Emails
I received an email from the client about what the project will need to do. +

==== The Email
Welcome to the seemingly easy world of tenpin bowling league management +
All of this is currently managed through a number of Excel worksheets linked together, with a load of macros to produce the static web pages and the scoresheets for each week with the updated averages, handicaps and league standings.  The web pages are then uploaded to the website each week.
It would be great to get to a point where the data entry can be done directly into a [database] on the web server so it can be done from anywhere (and in theory, by anyone).  This would help when I am on holiday.  Then we can look at webpages that don’t need to be uploaded, they would simply get data out of the database.
I think it would make sense to meet up so I can show you the mess I work with (which causes headaches at the start of each season when I tweak it to fit – and inevitably break something).  That way you’ll also be able to ask “why on earth do you do that”, or “you never mentioned that”.  Maybe I can show you how I setup a new season, which is when I really find out the bits I need!

==== Background
The basic structure is that we have a number of teams competing over a number of weeks which make up a season.  Each team can have up to 9 bowlers registered and actively bowling.  A bowler can switch from one team to another mid-season, however they can only move once during the season.  When this happens, their average and handicap move with them.  This happens rarely but does happen.

==== Handicapping
The league runs a handicapping system providing additional points to a bowler based on their current average score.  The calculation that we use in Excel is =INT(((200-INT(bowler_average))*0.8)  There is a maximum handicap of 80 and a minimum of 0.
A bowler with an average of 180 has a handicap of 16 ((200-180)*0.8), an average of 180.9 is the same.
A bowler with an average of 90 has a handicap of 80 ((200-90)*0.8) = 88 (more than the maximum)
A new bowler joining the league will not have an average, hence no handicap; they will receive a handicap based on their first night’s scores.  So, if Lucy, in the example below, had bowled those scores on the first night, her handicap would have been 64 based on her average of 120.  This then is applied to her scratch scores – she would have won her individual match 6-2 instead of losing 3-5!
To keep the handicap current, we use the last 24 scratch game scores to calculate the average for each bowler.  Just to be confusing, we do also note the average for all league matches through the season (this is used to determine the “high season average” award – but enough of awards!
The “blind” score is simply calculated by adding the bowler’s average to their handicap and rounding down… average of 120 = handicap of 64 = blind score of 164 which they would need to beat to win points if the opponent didn't turn up.

==== Scoring
Each week 3 bowlers per team take part and play 3 games each.  In reality, it is more complicated or flexible than this.  It could be that each game is played by a different bowler, in the event people get injured; so we need the flexibility for each game to be attributed to a different bowler with a different handicap.
Example scoresheet (from the website)

image::other-pictures/TeamVTeam.png[leagueTable,pdfwidth=100%]

In the match above Lucy Scott is competing directly against David Henn (first bowler for each team).
Their individual match is made up of 4 elements; game 1, game 2, game 3 and the series.  I currently record the scratch score (131 for Lucy and 108 for David), their handicap and the bowler name.  Once the handicap is added to the scratch score we get the handicapped score, this is what is compared to determine who won the points.  In this case Lucy’s handicapped score is 189 which beats David’s handicapped score of 163, so Lucy is awarded 2 points for game 1.  The points are awarded for games 2 and 3 and finally for the series totals.  In this instance because the scores are tied (534) they both are awarded 1 point.
In theory, we could calculate the handicap “on the fly”, however recording the handicap as a static value it allows for the anomalies we see at various times during a season (postponement of matches).
Score is each 2 points for a win,1 point for a draw (equal score). 32 points are available each week:
Each bowler 2 points per game (3 games) plus 2 points for the total (series) score with handicap. Scored against their equivalent bowler on the opposite team (based on who bowls 1st/2nd/3rd). So each bowler can score up to 8 points 
The team total counts as another pseudo-bowler and is scored the same way – total per game and grand-total 
The handicap score (meaning the bowlers actual or “scratch” score plus their handicap) is always used to work out who won/lost/tied.

==== League Standings
image::other-pictures/LeagueStandings.png[leagueTable,pdfwidth=100%]

The league table page shows

* *HHG** = High Handicap Game (the total team score not per bowler) +
* *HHS** = High Handicap Series (series = sum of the 3 games played any week, again for the team total) +
* *Pins for* = total of the scratch scores scored by the team to date +
* *Pins against*  = total of their oppositions scores each week to date +
* *Team Pts* = total points won by the team pseudo bowler each week +
* *Total Pts* = all points won by the team +
* *There is a “Season” and “All” value for each of these – based on the fact we run a cup competition each season.

That covers the basics of the scoring and how points are allocated.  From all of this, I provide a large number of stats (because I am go through phases of being interested in it. +

===== The Cup
The cup competition that runs for a few weeks during the year is also managed this way – but more as an afterthought.  The mechanism for determining points can be different to the normal league depending upon how we manage it; normally it’s different when we have an odd number of teams.
For each team we see a summary of the score each week and some individual achievements.  There is a great deal of detail (which I have put together because it was available)… we can make this “phase 2”
Ian’s comments I haven’t addressed elsewhere

Some weeks teams will agree to postpone their game. They catch up the missed games later in the season +

* This is where the static handicap is useful, with the option to override it.
Bowler’s stats are rolled over between seasons (so they continue with the average from last season at the start of a new season) +
* Their last 24 games are used to roll their average to the new season.  If they haven’t bowled 24 games, then up to 24 games are carried over; if it’s less than 6 games then they will start as if new.  All achievements are carried over (awards for a 200 game, or 6 consecutive strikes) +
There could be a different number of teams some seasons +
* If it’s an odd number the league make the decision to either bowl against the “blind”, or to have a week of no bowling.
A team could drop out mid-season and scores must be removed from each weeks results (is that right Phil?) +
* It depends, I will check the constitution; if they have bowled against each team just once but a couple of teams twice, we might remove the extra couple of results.  We normally encourage them to bowl to a natural break point, but it’s not always possible.
At the start of the season the system needs to generate a list of matches – which team is playing which other team and on which lanes. The teams need to be put on each lane an equal number of times as far as possible and play each other team twice (maybe 3 times if the number of teams is low enough and there are enough weeks available).
If the league has 10 teams assume lanes 1 to 10 are used each week +
*  We are typically a 10 team league and to be awkward we use lanes 3 to 12 but if we have 10 lane identifiers, we can modify them to be the lanes we actually use. +
Some weeks are used for non-league matches (special competitions as teams or individuals tournaments). Some weeks each summer there is no bowling (too maybe people on holiday so we stop). Also bank holidays there is no playing. +
*  We need a mechanism for recording these scores (we currently use a different area of the spreadsheet to record these, so they are not included within the range used for calculating averages and handicaps but within the range used for awards. +

=== Next stuff
On top of this existing criteria the current project should have a login system to allow users to add scores for their games. This will need to be confirmed by the other team.

== Planning

=== What objects, and what do they have
[source,json]
----
League{
	"teams": ["Team", "Team", "..."],
	"rota": ["Game", "Game", "..."],
	"ranking": computed
}

Team{
    "name": "String"
    "Image": "Image"
	"players": ["Player", "Player", "..."]
	"score": "Score Object"
}

Player{
    "name": "String"
	"score": "Score Object"
}

User{
	"ID": "47q047309-47120-97410-298490"
    "team": "Team"
    "player": "Player"
    "rank": "leagueAdmin || teamOwner || scoreAdder"
}

Game{
	"score": "Score Object"
	"time": "yyyy/mm/dd"
	"venue": "Venue"
	"status": "complete || in progress || not started"
}
----

=== Database modelling
.All objects
[caption="Database modelling: "]
image::other-pictures/database_planning.jpg[database,pdfwidth=100%]
This was the initial modelling of the database. It shows the relationship between all the objects. User and Role are for
security and will be added later than the others.

=== Api planning
An API should follow a pattern to be easy to predict where one can make or retrieve an object. I decided to have a base
url for the back end of /api/ this allows me to change it and add it as new base url later and easily separate the front
and back end usage of the application. Past this it makes sense that /{ObjectName}/{id} should be where one would get,
delete or modify an object. Where many will need to be retrieved by a user, a /{ObjectName} should get all or all with
certain criteria.

=== Technologies
I will use springboot and java for the backend. I will use this as java runs well on many platforms. Springboot makes it easy for me to add things into the project.
The front end will be written in React JS. I used this as it is very easy to find documentation and sources on how to write it. I will also use material design for styling.
The database structure will probably be best in a relational database so a springboot SQL database will be used such as H2 and JPA to communicate nicely.
I will use nightwatch for integration testing. This will allow me to automatically use the website, expect behaviour, and take screenshots during. I will use a python script to put all the testing data into the writeup automatically.
To allow easy script modification of the writeup it will be written in asciidoc and made into a pdf with asciidoctor-pdf, the source is plain text and can be easily modified. It supports code highlighting etc as well.
It should use OAuth to authenticate so users don't require another password.

=== Design
Upon talking to the client it was established that all original features of the site were important. +
There will be support for multiple types of tournament including elimination and round robin brackets. +
A logged in user will be defaulted to a page of their and their teams statistics. +
The style is not important other than the website should be mobile compatible. +
There should be support for multiple leagues. +
To start a new season of a league it should duplicate the previous and delete parts.
To move players only a leagueAdmin can move them. +
A shortcut should be made to use the API without a frontend to allow for scripts to do a task faster.

=== Research
I did some research on web applications with data support. Spring boot with react seems to be a popular solution due to
the support with both web controllers and also JPA support for sql databases.
After modelling the database it appears that a relational database would be most fitting so I used a sql database in H2
as it is easy to setup in http://start.spring.io/. I decided to use react despite facebook licensing due to
it being a popular language with many examples online. React allows me to write JSX which is similar to HTML.

=== Testing
Testing will largely be automated by use of unit testing and nightwatch. +
Nightwatch will be used in order to test the entire application by it's user interface and report on whether or not it is working as intended. It will also take screenshots of the application to allow a developer to quickly look over these screenshots as opposed to having to navigate the website. This allows for quick testing of all versions without the necessity for user input. +
Unit testing will be done to check the functionality of functions. If a function works correctly the test will pass and will then be reported as such. This allows for observation of individual functions to find where errors are occuring. +
The data will then be written into the writeup by script in order to have a repeated structure of testing.

=== Ordering
The project will start by laying out the backend for an object, like a league, and then there will be a front end
implementation of the object. The ordering will be League, Team, Player, Match, Score then User and roles for security.

=== Iterative Development
Every time a feature is implemented, changes will be pushed to a github repository. Any in progress changes will be pushed to a
separate "dev" branch and merged into master when feature is complete and tested. This allows users and stakeholders to always have
an up to date version of the code to continuously provide feedback on future versions.

== Development

=== Initial Setup
Using IDEA and springboot I can generate a springboot project with certain libraries pre added.

.New Projects
[caption="Step 1: "]
image::dev-pictures/Setup1.png[leagueTable,pdfwidth=100%]

.Springboot Project
[caption="Step 2: "]
image::dev-pictures/Setup2.png[leagueTable,pdfwidth=100%]

.Setting up metadata
[caption="Step 3: "]
image::dev-pictures/Setup3.png[leagueTable,pdfwidth=100%]

.Choosing dependancies
[caption="Step 4: "]
image::dev-pictures/Setup4.png[leagueTable,pdfwidth=100%]


.Naming Project
[caption="Step 5: "]
image::dev-pictures/Setup5.png[leagueTable,pdfwidth=100%]

This creates us a simple springboot project with a pre-made build.gradle and a BowlingApplication
and BowlingApplicationTests.

Theses can be left alone for now

=== Modelling The Objects
We already decided what objects should do what, so now we add most of the objects
To start not all the objects were added so core functionality could be completed first.

Inside the src/main/java/ folder we go into com.saskcow.bowling, this is where the domain package is made
inside this is where the objects will be stored, each object should have most of the features in planning
Notably scores and users have been omitted in this version.

==== League.java
_Imports condensed_
[source,java]
----
package com.saskcow.bowling.domain;

import ...

@Data // Creates a getter and setter for each property
@Entity // JPA annotation, makes it good to store in a database
@NoArgsConstructor // Creates a constructor with nothing
@AllArgsConstructor // Creates a constructor with everything
public class League {
    private @Id @GeneratedValue Long id;
    // Generate a long value to be used as ID, always unique
    private String name;
    // Name Property of the class
    @OneToMany(mappedBy = "league", cascade = CascadeType.ALL)
    // This prevents a "Failed to load ApplicationContext" error
    // Additionally the properties of it say if the league is deleted, as are all the teams
    private List<Team> teams;
    // List<Team> just a list of the teams, type specified in java

    public League(String name, List<Team> teams){
        // A constructor, sets name and teams to what it was created with ID autogenerated
        this.name = name;
        this.teams = teams;
    }
}
----
WARNING: Ensure @ManyToOne etc set to avoid <<many-to-one-error,"Failed to load ApplicationContext">>

==== Team.java
_Imports condensed_
[source,java]
----
package com.saskcow.bowling.domain;

import ...

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
//Same as with League
public class Team {
    private @Id @GeneratedValue Long id;
        private String name;
        @OneToMany(mappedBy = "team", cascade = CascadeType.ALL)
        // Players part of team, so a team will change players on its change
        private List<Player> players;
        @ManyToMany
        // Teams have many games, games have 2 teams so a manytomany is identified
        private List<Game> games;
        @ManyToOne
        private League league;

    // A constructor with everything but generating the id
    public Team(String name, List<Player> players, List<Game> games, League league) {
        this.name = name;
        this.players = players;
        this.games = games;
        this.league = league;
    }

    // A second constructor is put in place in order to create a team which has no players or games
    public Team(String name, League league) {
        this.name = name;
        this.league = league;
        this.players = new LinkedList<>();
        this.games = new LinkedList<>();
    }
}
----

==== Player.java
_Imports condensed_ +
Very similar to previous, nothing new used.
[source,java]
----
package com.saskcow.bowling.domain;

import ...

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
//Same as with League
public class Team {
    private @Id @GeneratedValue Long id;
        private String name;
        @ManyToOne
        private Team team;

        public Player(String name, Team team) {
            this.name = name;
            this.team = team;
        }
}
----

==== Game.java
_Imports condensed_ +
Also very similar to previous, nothing new used.
[source,java]
----
package com.saskcow.bowling.domain;

import ...

@Data
@Entity
@AllArgsConstructor
@NoArgsConstructor
public class Game {
    private @Id @GeneratedValue Long id;
    private LocalDateTime time;
    private String venue;
    @ManyToMany
    private List<Team> teams;
    // Should only ever have 2 values, not enforced

    public Game(LocalDateTime time, String venue, List<Team> teams) {
        this.time = time;
        this.venue = venue;
        this.teams = teams;
    }
}
----

==== Errors at this stage
This stage was fairly simple so few errors occurred other than occasional mistypes picked up by
the ide as it went along. It is also hard to find errors at this stage due to nothing happening.

[#many-to-one-error]
===== @ManyToOne, @OneToMany, @ManyToMany annotations
Without these annotations in place a java.lang.IllegalStateException is raised

.Start of stacktrace
image::error-pictures/failed-context.png[AppContext,pdfwidth=100%]

by adding the
[source,java]
----
@ManyToOne
@OneToMany
@ManyToMany
----
this exception is no longer raised allowing it to compile

=== Repositories
Repositories in java are very simple to implement, all repositories can be created with
_{ObjectName} to be substituted with League, Team, Player and Game_

[source,java]
----
package com.saskcow.bowling.repository;

import ...

// Create a new Repository which copies a CrudRepository so it has all the functions
//<ObjectName, Long> shows it stores ObjectName by a Long, the Long being the id of the object.
public interface ObjectName Repository extends CrudRepository<ObjectName, Long> {
}
----

At this stage this is all that was done for each object and it was saved as {ObjectName}Repository.java
inside com.saskcow.bowling.repository

==== Errors at this stage
Errors this stage were created by trying to figure out whether or not some CrudRepository things were worth changing +
They weren't.

[#crud-repo]
===== CrudRepository checking
If the <{ObjectName}, Long> is changed it stores a different type object and returns a different type,
so the object cannot be retrieved as itself.

.Compiler Error
image::error-pictures/crudrepo-string.png[AppContext,pdfwidth=100%]

this occurs as a Game object cannot be made from a String, which is the returned object.

=== Controllers
There are a lot of controllers in this project, and they are a crucial part to communicate
with the frontend to start with, a HomeController will be made to return some basic HTML

==== index.ftl
This file is where all the front end will be, currently it will just show a blank page,
due to spring security, a default password can be set in spring application.properties.

.Authentication
image::dev-pictures/auth.png[Auth]

[source]
----
<html>
<head lang="en">
    <meta charset="UTF-8"/>
    <title>Bowling</title>
    <link rel="stylesheet" href="/style.css"/>
    <link rel="stylesheet" href="/material.min.css"/>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <#--These are in place to get some css to make some elements look slightly nicer-->
    <#--/style.css is currently blank-->
</head>
<body>

<div id="react"></div>
<#--create a div for ReactDOM to later use-->

<script src="/built/bundle.js"></script>
<#--load the webpack script, this will be created later-->
<#--webpack is what takes all the js and makes it one file-->

</body>
</html>
----

==== HomeController.java
This will route to the javascript and ftl to sort out the front end

[source,java]
----
package com.saskcow.bowling.controller;

import ...

@Controller
// Look here for request mappings
public class HomeController {

    @RequestMapping(value = {"/"})
    // Any requests to / call this function
    // Later more will be added as more paths are in the front end
    public String index(){
        return "index";
        // Show index file extension guessed, currently .ftl
    }
}
----

==== Errors at this stage
Only here as they are waiting for future things, which don't exist yet.
Or due to user error.

===== 404 Errors
Due to some parts being missing, the browser shows errors in console where it can't find
bundle.js or other parts.

.404 on bundle.js
image::error-pictures/no-bundle.png[MissingBundle]

===== Multiple Launched Errors
When launched, anything else trying to use the port is blocked, this gives the
not especially clear Execution failed for task bootRun as it fails to launch

.Launch Interrupted
image::error-pictures/already-launched.png[AlreadyLaunched,pdfwidth=100%]

=== League Controller
Create mappings for the creating, getting and removing leagues, these will be called from the frontend

==== LeagueControllerTest.java
Inside the src/test/java I create a folder called controller, this is where I will put controller tests.
It is important to test controllers as REST Apis should have consistent features.
This helps decide what parts are important, here I identify that we need to be able to make, filter, retrieve and delete leagues
as basic functionality.

[source,java]
----
package com.saskcow.bowling.controller;

import ...

@RunWith(MockitoJUnitRunner.class) // This runs the tests with a testRunner, this allows assertions which would otherwise be not allowed
public class LeagueControllerTest {

    @Mock
    private LeagueRepository repo;
    // Create a LeagueRepository like thing, which does nothing, just pretends it exists, that's what @Mock does
    private MockMvc mockMvc;
    // Creates a MockMvc to test the api endpoints

    @Before
    //Run before tests
    public void setUp(){
        mockMvc = MockMvcBuilders.standaloneSetup(new LeagueController(repo)).build();
        // Create a LeagueController and run it
    }

    @Test
    // Run this when running tests, ran by MockitoJUnitRunner
    public void addLeague_shouldSaveTheLeague() throws Exception {
        // Doesn't return anything, throws Exception if any part fails, calls test addLeague_shouldSaveTheLeague
        League league = new League(1L, "Brian", new LinkedList<>());
        // Create an instance of a League, the object from earlier
        Team team = new Team("Team Brian", league);
        league.addTeam(team);
        // Give it a team, because leagues have those
        when(repo.save(isA(League.class))).thenReturn(league);
        // If someone saves a league, return a League, this is what the repo would do, but the League here is always the same
        when(repo.findOne(league.getId())).thenReturn(league);
        // If someone tries to find this league by its ID, return it
        when(repo.findAll()).thenReturn(Collections.singletonList(league));
        // If someone tries to find all leagues, return this in a list as the only League

        String uri = mockMvc.perform(post("/api/league")
                // String uri, save the output as a string
                // mockMvc stuff sends a post request to the endpoint
                .content("{\"name\":\"Brian\"}")
                // Send it with this content
                .contentType("application/json"))
                // This content is JSON
                .andExpect(status().isCreated())
                // Should return a 201 (created), if it isn't throw Exception
                .andExpect(header().string("Location", "http://localhost:8080/api/league/" + league.getId()))
                // Inside the header the location of where the saved object can be retrieved should be present
                .andReturn().getResponse().getHeader("Location");
                // Save the location header to uri

        mockMvc.perform(get("/api/league"))
                // Send a get request to the endpoint
                .andExpect(status().isOk())
                // Check status is 200 (OK)
                .andExpect(MockMvcResultMatchers.jsonPath("$", hasSize(1)))
                // Check that the JSON is an array with size 1
                .andExpect(MockMvcResultMatchers.jsonPath("$[0].name", equalTo("Brian")));
                // Check the first part of the json has a name of "Brian", like the league earlier

        mockMvc.perform(get(uri))
                // Send a get request to where the location of the league is
                .andExpect(status().isOk())
                .andExpect(MockMvcResultMatchers.jsonPath("$.name", equalTo("Brian")))
                // Check that it has the name Brian
                .andExpect(MockMvcResultMatchers.jsonPath("name", equalTo("Brian")));
                // Check again, by a slightly different method

    }

    @Test
    public void getLeague_shouldFilter() throws Exception {
        League dave = new League(1L, "Dave", null );
        League david = new League(2L, "David", null );
        League brian = new League(3L, "Brian", null);
        // Create 3 leagues
        when(repo.findAll()).thenReturn(Arrays.asList(dave, david, brian));
        // when it calls findByNameContaining("Dav") then it should return all which have "Dav" in the name
        // findByNameContaining must be added as it is not in CrudRepository
        when(repo.findByNameContaining("Dav")).thenReturn(Arrays.asList(dave, david));
        // Same but with Bri
        when(repo.findByNameContaining("Bri")).thenReturn(Collections.singletonList(brian));

        // We don't do the post request as one already exists
        mockMvc.perform(get("/api/league?name=Dav"))
                // call the endpoint with a query string with name=Dav
                .andExpect(status().isOk())
                .andExpect(MockMvcResultMatchers.jsonPath("$", hasSize(2)))
                // Expect 2 items in the returned array
                .andExpect(MockMvcResultMatchers.jsonPath("$[0].name", equalTo("Dave")))
                .andExpect(MockMvcResultMatchers.jsonPath("$[1].name", equalTo("David")));
                // Expect that the list is as expected, we only know the order as it is set earlier
                // Ordinarily order can not be expected

        mockMvc.perform(get("/api/league?name=Bri"))
                // get all leagues with Bri
                .andExpect(status().isOk())
                .andExpect(MockMvcResultMatchers.jsonPath("$", hasSize(1)))
                .andExpect(MockMvcResultMatchers.jsonPath("$[0].name", equalTo("Brian")));
                // Check it has 1 item, which is Brian
    }

    @Test
    public void deleteLeague_shouldDeleteLeague() throws Exception {
        doNothing().when(repo).delete(isA(Long.class));
        // When repo.delete is called with an ID, do nothing, nothing at all

        mockMvc.perform(delete("/api/league/1"))
                // Send a delete request
                .andExpect(status().isNoContent());
                // Expect a 204, No Content is returned
        verify(repo, times(1)).delete(1L);
        // Check it actually called delete
        }
}
----

Note at this point there is no controller, so all this fails, and is therefore an error,
this is fixed by creating the controller.

.No Controller Exists
image::error-pictures/no-controller.png[NoController,pdfwidth=100%]

==== LeagueController.java
Next is to create the controller, this will route all requests concerning leagues. It will return ResponseEntity s
this allows for HTTP codes such as 200 or 204 to be sent, as the tests expected

[source,java]
----
package com.saskcow.bowling.controller;

import ...

@Controller
public class LeagueController {

    private LeagueRepository repo;
    // Has an instance of LeagueRepository

    @Autowired
    // Gets it from application context  and injects automatically
    public LeagueController(LeagueRepository repo){
        // Constructor sets repository from app context
        this.repo = repo;
    }

    @RequestMapping(value = "/api/league", method = RequestMethod.GET)
    // For most get requests at /api/league run this function
    public ResponseEntity<List<LeagueViewSummary>> findLeagues() {
        // Return a ResponseEntity containing an List of LeagueViewSummary objects
        List<LeagueViewSummary> leagues = StreamSupport.stream(repo.findAll().spliterator(), false)
                .map(LeagueViewSummary::new).collect(Collectors.toList());
        // Get the leagues, and stream them after splitting the iterator up
        // Map the stream so each value is replaced by the value of new LeagueViewSummary(value)
        // Collect this into a list
        // Have to use StreamSupport see error

        /*
        List<LeagueViewSummary> leagues = new ArrayList<>();
        repo.findAll().
                forEach(league -> leagues.add(new LeagueViewSummary(league))); */
        // This was the original implementation but it was replaced with streams for cleaner code

        return ResponseEntity.ok(leagues);
        // return OK (200) with body of leagues, which has LeagueViewSummary which can be converted to JSON
    }

    @RequestMapping(value = "/api/league", method = RequestMethod.GET, params = "name")
    // For all get requests at /api/league which have ?name={A name} at the end of the url
    public ResponseEntity<List<LeagueViewSummary>> findLeaguesByName(@RequestParam("name") String name) {
        List<LeagueViewSummary> leagues = repo.findByNameContaining(name).stream()
                .map(LeagueViewSummary::new).collect(Collectors.toList());
        // repo.findByNameContainint(League) already is a list so has a .stream already
        return ResponseEntity.ok(leagues);
    }

    @RequestMapping(value = "/api/league/{id}", method = RequestMethod.GET)
    // For all get requests with /id , id is variable
    public ResponseEntity<LeagueView> findLeague(@PathVariable("id") Long id) {
        // return a LeagueView in a ResponseEntity, take the path variable id as a variable
        League league = repo.findOne(id);
        // Get the league from the database
        LeagueView leagueView = new LeagueView(league);
        // Make it a LeagueView
        return ResponseEntity.ok(leagueView);
        // Send it off
    }

    @RequestMapping(value = "/api/league", method = RequestMethod.POST)
    // For all post requests to /api/league
    public ResponseEntity<?> saveLeague(@RequestBody League league) {
        // take request body and convert the JSON into a League
        // This will use the constructor with Name as the name in JSON and teams as null as teams cannot be shown in JSON
        if(league.getTeams() == null){
            // If by some miracle someone sends teams in JSON, let them
            league.setTeams(new LinkedList<>());
            // Otherwise use this empty list here and add them after
        }
        League savedLeague = repo.save(league);
        // Save the league to the database
        URI location = ServletUriComponentsBuilder
                // Build a URI
                .fromCurrentRequest().path("/{id}")
                // Get the path to here (/api/league) and add /{id} to it
                .buildAndExpand(savedLeague.getId()).toUri();
                // Set the {id} to the id and make the URI
        return ResponseEntity.created(location).build();
        // Send back a created (201) and with a location of where they could find the item
    }

    @RequestMapping(value = "/api/league/{id}", method = RequestMethod.DELETE)
    // All delete requests to /api/league/{id} go here
    public ResponseEntity<Void> deleteLeague(@PathVariable("id") Long id) {
        // Get the ID from the request, and return a ResponseEntity with nothing in it (Void)
        try {
            repo.delete(id);
            // Delete the league
            return ResponseEntity.noContent().build();
            // Return a no content (204) for successful deletion
        } catch (EmptyResultDataAccessException e) {
            // If the league was not found, do this instead
            return ResponseEntity.notFound().build();
            // Return a not found error
            // Since it's 4XX it lets the user know it's there fault not mine
        }
    }


}

----

WARNING: Once again this is part of multiple files implementing the features so once again it won't run as
TeamViewSummary and TeamView don't exist, also the repository doesn't have a findByNameContaining

==== LeagueRepository.java
So the easiest bit to fix is there is no findByNameContaining, this is necessary otherwise <<find-by-name-containing, wrong results>>
This just involves adding
[source,java]
----
List<League> findByNameContaining(String name);
----
to LeagueRepository.java, this adds the function findByNameContaining.
Spring takes this and based off of the name of the method creates the JPQL query similar to
[source,sql]
----
SELECT x FROM Leagues x WHERE x.name LIKE ?1
----
Due to the generation of the the table being done by spring, this may not be the exact JPQL, details can be found at
https://docs.spring.io/spring-data/jpa/docs/1.5.1.RELEASE/reference/html/jpa.repositories.html#jpa.query-methods.query-creation

==== LeagueView.java
This is an object returned by the controller containing what would be a reasonable amount of information about a League.
This is necessary as one-one relationships cause problems with converting to JSON, this results in all Requests

.League and Team Recursion
image::error-pictures/league-not-view.png[StackOverflow,pdfwidth=100%]

as found by the tests, to solve this we make view objects.

[source,java]
----
package com.saskcow.bowling.view;

import ...

@Data
// Getters and Setters and more all done
@NoArgsConstructor
//Can make one with nothing
public class LeagueView {
    private Long id;
    private String name;
    private List<TeamViewSummary> teams;
    // Has a list of summary objects, currently these have nothing so no errors occur, but it makes things
    private List<GameView> games;
    // Has a list of GameView for the same reason


    public LeagueView(League league) {
        this.name = league.getName();
        this.id = league.getId();

        this.teams = league.getTeams() == null ? new LinkedList<>() : league.getTeams().stream().map(TeamViewSummary::new).collect(Collectors.toList());
        this.games = league.getGames() == null ? new LinkedList<>() : league.getGames().stream().map(GameView::new).collect(Collectors.toList());
        // A lot like the streams earlier, but with a ternary operator, so if teams is null, it's now an empty list
        // Also the view objects are blank so nothing happens, but no error occurs
    }
}
----

==== LeagueViewSummary
Sometimes you only want a bit of information about a league, such as the name of it and the id so you can find out more.
This can be easily sent with a ViewSummary, which is a very simple description of a League.

[source,java]
----
package com.saskcow.bowling.view;

import ...

@Data
@NoArgsConstructor
public class LeagueViewSummary {
    // A lot like league, only less, currently does the same as teams and games don't have view objects
    private Long id;
    private String name;


    public LeagueViewSummary(League league) {
        this.name = league.getName();
        this.id = league.getId();
    }
}
----

==== Errors at this stage

[find-by-name-not-containing]
===== findByName not containing
originally I tried using findByName, which only matches full name, because of this when I was expecting there to be
1 leagues returned, there were none as it was not an exact match. This is as bad as windows searching, can't have that.

[red]#expected:<[1]> but was:<[0]># +
Expected : [red]#1# +
Actual   : [red]#0# +

to fix this by adding Containing to the end of findByName it now checks it the string is in the name, this works far better.

===== NullPointer the first
Probably the first of many, this error occurred when I forgot to mock a function

.Missed Mock of function
image::error-pictures/null-pointer-no-mock.png[NoMock,pdfwidth=100%]

This can be fixed in this instance by going to LeagueController.java:59 (further down stack) and finding that
the savedLeague.getId() isn't working as there is no mock, savedLeague is null.

This can be fixed with
[source,java]
----
when(repo.save(isA(League.class))).thenReturn(league);
----
or a similar mock dependant on what's missing. This fixes the issue.

===== StreamSupport necessary
With the streams, lists have a .stream() method, iterators don't as it turns out.

.No token stream()
image::error-pictures/iterators-cannot-stream.png[NoStream,pdfwidth=100%]

To fix this these must be converted into streams differently before .map() this can be done with
StreamSupport, this allows for Spliterator to go to streams. By using
[source,java]
----
StreamSupport.stream(repo.findAll().spliterator(), false)
----
it takes the iterator and makes it a spliterator before turning it into a stream, ready to .map like the other streams.

=== Front End Setup
For a front end it's fairly simple to add nicely, however there are important steps to do first.
The main steps required now are:
* Webpack
* Babel, I'm not writing this in ES5
* NPM setup

==== Npm Setup
Since the other 2 steps rely on node, I need to setup NPM first.
NPM is a package manager which can be used for javascript modules, this makes it easy to manage dependencies and setup
other things.
By running `npm init` npm becomes easy to setup as it asks step by step for parts, for now it can mostly be left default.
Dependencies must now be installed. By doing `npm install --save package-name` or `npm install --save-dev package-name`
they get added to package.json, which should look something like this.
[source,json]
----
{
  "name": "Bowling",
  "version": "1.0.0",
  "description": "Bowling League Management",
  "dependencies": {
    "react": "^15.3.2",
    "react-dom": "^15.3.2",
    "react-router-dom": "^4.2.2",
    "webpack": "^1.12.2"
  },
  "devDependencies": {
    "babel-core": "^6.18.2",
    "babel-loader": "^6.2.7",
    "babel-plugin-transform-decorators-legacy": "^1.3.4",
    "babel-polyfill": "^6.16.0",
    "babel-preset-env": "^1.6.1",
    "babel-preset-react": "^6.16.0",
    "babel-preset-stage-0": "^6.24.1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/saskcow/bowling.git"
  },
  "author": "Callum Tarttelin",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/saskcow/bowling/issues"
  },
  "homepage": "https://github.com/saskcow/bowling#readme"
}
----
This includes the dependencies I added after.

==== webpack.config.js
I created this top level file which details how webpack should "bundle" the files before use. Webpack should put all the
js into one bundle.js file to be sourced from the template (index.ftl). By editing a basic one I found in docs I made
[source,js]
----
const path = require('path');
// import path

module.exports = {
    // Export this JSON
    entry: './src/main/js/app.js',
    // The main file
    devtool: 'sourcemaps',
    cache: true,
    debug: true,
    output: {
        path: __dirname,
        filename: './src/main/resources/static/built/bundle.js'
        // Put the final file where it is expected
    },
    module: {
        loaders: [
            {
                test: path.join(__dirname, '.'),
                exclude: /(node_modules)/,
                loader: 'babel',
                query: {
                    cacheDirectory: true,
                    presets: ['env', 'react', 'stage-0']
                    // presets say to run babel presets from the array
                }
            }
        ]
    }
};
----

This babels and bundles it all into one file.

==== Babel
Babel is a transpiler, this takes my javascript I write, and turns it into javascript. The difference is I can write ES6,
ES next decorators and react JSX, and it will make it into ES5. This is important as no browser fully supports all these
features, so babel translates it so that the browser can use it, and I can write in easier to write languages.

==== Errors At This Stage
Since this is all follow steps and the webpack is following the structure expected, no errors occurred in this step.
Which is of course, unheard of, and also rather convenient.

=== Front End for leagues
A bit of back end and preparation later and we are ready to create a front end, this will be rather ugly for now, but
later some css can be thrown at it till it looks less bad, but css is not something I'm good at.

==== Dependencies
First I need to add some dependencies to my package.json the main ones are axios for REST requests, and material-ui and
icons to make it look nicer as well as react-router-dom.
[source,json]
----
"dependencies": {
    "axios": "^0.17.1",
    "material-ui": "^1.0.0-beta.31",
    "material-ui-icons": "^1.0.0-beta.17",
    "react": "^15.3.2",
    "react-dom": "^15.3.2",
    "react-router-dom": "^4.2.2",
    "rest": "^1.3.1",
    "webpack": "^1.12.2"
  }
----

==== app.js
In src/main/js App.js is added. This is the main file which the front end is made off of. This will be used to route the
front end paths.

[source,js]
----
import ...

class App extends React.Component {
  // React.Component is extended giving this class state, props etc nicely
  render() {
    // Method called when it is rendered on a screen
    return (
      // JSX returned to make into HTML to display
      <Router>
        {/*React Router BrowserRouter which creates a router which can have routes here*/}
        <div className="App">
          <Route exact path="/" component={LeagueList}/>
          {/*If at path / show LeagueList component*/}
          <Route exact path="/league" component={LeagueList}/>
          <Route exact path="/league/:id" component={League}/>
          <Route path="/add/league" component={AddLeague}/>
          {/*Could match multiple but not setup to, as I don't want it to*/}
        </div>
      </Router>
    )
  }
}

ReactDOM.render(
// When imported this runs and renders some JSX
<App/>,
// Render App from above
  document.getElementById('react')
  // Put it in the 'react' element in the template
);

----

==== LeagueSummary.js
We need a way to display the summary information, which is pretty much just a name and an ID. Using the id to link to
more information we are able to just have a hyperlinked name and we can put many of these in a list

[source,js]
----
import ...

class LeagueSummary extends React.Component {
  render() {
    return (
      <li className={this.props.children.replace(/\s+/g, '-').toLowerCase()}>
        {/*Create a list element with name same as league, "-" instead of " "*/}
        <Link to={'/league/' + this.props.id.toString()}>
          {/*Link it to "/league/:id" so that it can go to the more details page*/}
          {this.props.children} {/*Write the name of the league*/}
        </Link>
        <Delete id={this.props.id} type={'league'} name={this.props.children}/>
        {/*Create a delete for a league with this ID, onclick delete the league*/}
      </li>
    )
  }
}

export default LeagueSummary;
----

==== LeagueList.js
Here is where the LeagueSummary will be used, this needs to get all the leagues from the java and display them all.

[source,js]
----
import ...

class LeagueList extends React.Component {
  constructor() { // Run when component created
    super(); // make usable
    this.state = ({status: "Loading"}); // Set state to Loading
    this.updateLeagues = this.updateLeagues.bind(this);
    this.refresh = this.refresh.bind(this);
    // Give functions this
    this.updateLeagues() // Get the leagues
  }

  updateLeagues() {
    axios.get('/api/league')
      .then(response => { // When complete
        this.setState({status: "OK", leagues: response.data})
        // Set status and the leagues from the request
      })
      .catch(error => { // Run this if there is an error
        if (error.response) {
          this.setState({status: "error", err: error.response.data});
        } else if (error.request) {
          this.setState({status: "error", err: "No Response"});
          console.log(error.request);
        } else {
          this.setState({status: "error", err: "Error with Request"});
          console.log('Error', error.message);
        }
        // Display error to user, dependant on error
      });
  }

  refresh() { // Get leagues again and set as loading
    this.setState({status: "Loading"});
    this.updateLeagues()
  }

  render() {
    console.log(this.state.status);
    if (this.state.status === "Loading") {
      // If it is loading
      return (
        <div className={"Loading"}>
          <CircularProgress color={"primary"} />
          {/*Create a loading wheel with primary colour*/}
        </div>
      )
    } else if (this.state.status === "Error") {
      // If there is an error, give a reset button and show that there is an error
      return (
        <div className={"Error"}>
          <h2>Error</h2>
          <Button variant={"raised"} color={'primary'} className={"RefreshButton"} onClick={this.refresh}>Refresh Leagues</Button>
        </div>
      )
    } else {
      // If there is no problem
      return (
        <div className={"Leagues"}>
          <ul>
            // Create an unordered list
            {this.state.leagues.map(league => (
              // For league in this.state.leagues
              <div key={league.id}> {/*When mapped it likes having a key, otherwise it gives a warning*/}
                <LeagueSummary id={league.id}>{league.name}</LeagueSummary>
                {/*Create a LeagueSummary with name and id*/}
              </div>
            ))}
          </ul>
          <Button variant={"raised"} color={"primary"} className={"RefreshButton"} onClick={this.refresh}>Refresh Leagues</Button>
          // Create a refresh button, onClick call refresh function
          <Link to={"/add/league"}><Button className={'add'} variant={"fab"} color={"primary"}><AddIcon /></Button></Link>
          // Create a hyperlink to /add/league with an add icon as a fab button
        </div>
      )
    }
  }
}

export default LeagueList; // Export LeagueList by default when LeagueList.js imported
----

==== League.js
This is the page corresponding to /api/league/id, at /league/id there will be a front end representation of the data.
This will be accessed from when a user clicks on a link to here.

[source,js]
----
import ...

class League extends React.Component {

  constructor(props) { // give access to props in constructor
    super();
    this.state = {status: "Loading"};
    this.getLeague = this.getLeague.bind(this);
    this.getLeague(props.match.params.id); // Call with the id from /:id
  }

  getLeague(id) {
    axios.get('/api/league/' + id)
      // Get a LeagueView
      .then(response => {
        this.setState({
          status: "OK",
          id: id,
          // Status is done, ID is set in case needed
          name: response.data.name,
          teams: response.data.teams,
          games: response.data.games
          // Set this.state.* to corresponding value from response
        })
      })
      .catch(error => {
        // Error catching
        if (error.response) {
          this.setState({status: "error", err: error.response.data});
        } else if (error.request) {
          this.setState({status: "error", err: "No Response"});
          console.log(error.request);
        } else {
          this.setState({status: "error", err: "Error with Request"});
          console.log('Error', error.message);
        }
      });
  }

  render() {
    if(this.state.status === "OK") {
      return (
        <div className={'League'}>

          <h2>{this.state.name}</h2>
          <Link to={"/league"}>Back</Link>
          {/*Title and link back to previous part*/}

        </div>
      )
    } else if (this.state.status === "error") {
      // If there is an error, show the error
      return (
        <h2>{this.state.err}</h2>
      )
    } else {
      // If loading, loading circle
      return <CircularProgress color={"primary"} />
    }
  }
}

export default League;
----

==== AddLeague.js
Page where one can add a league.

[source,js]
----
import ...

class AddLeague extends React.Component {
  constructor() {
    super();
    this.state = ({name: "No Name"});
    // Default name is No Name
    this.submit = this.submit.bind(this);
    this.updateName = this.updateName.bind(this);
  }

  submit(event) {
    event.preventDefault();
    axios.post("/api/league", {name: this.state.name})
      // Post what the name of the new league is
      .then(response => {
        window.location.href = '/league';
        // Redirect to '/league'
        this.state.name = "";
        console.log("created at " + response.headers.location);
        // Reset and log things
      })
      .catch(function (error) {
        console.log(error);
        // Simple error catching
      });
  }

  updateName(event) {
    this.setState({name: event.target.value})
    // change name in state to value of TextField
  }

  render() {
    return (
      <div className={"AddScreen"}>
        <h1>Add a league!</h1>
        <form className={"theLeagueForm"} onSubmit={this.submit}> {/*when submitted cakk submit*/}
          <TextField {/*Create a text entry*/}
            id="LeagueName"
            label="League Name" {/*Create a nice floating label on edit*/}
            placeholder="League Name"
            className={"LeagueNameInput"}
            onChange={this.updateName} {/*Update name in state whenever this is changed*/}
          /> <br />
          <Button type={"submit"} variant={"raised"} color={"primary"} className={"submitForm"}>Submit</Button>
          {/*Submit form*/}
        </form>
      </div>
    )
  }
}

export default AddLeague;
----

==== Delete.js
It is useful to be able to delete leagues. Sometimes too many are created, or some badly named, it's nice not to have to
create " BowlingLeague'); DROP TABLE Leagues; -- ", which sadly doesn't even work

.Protected against SQL Injection
image::other-pictures/little-leaguey-tables.png[SqlInjection]

So a deletion method is in order, so we need something to call the Delete from the backend.

[source,jsx]
----
import ...

class LeagueList extends React.Component {
  constructor(props) { // Have props in constructor
    super();
    this.state = ({status: "Loading", id: props.id, type: props.type});
    // Set type (currently league) and the id
    this.deleteThing = this.deleteThing.bind(this);
  }

  deleteThing() {
    axios.delete('/api/' + this.state.type + '/' + this.state.id)
      // Call at the delete url for the id and type
      .then(response => {
        location.reload(); // Refresh page
        console.log("deleted " + response.headers.location); // Log deletion
      })
      .catch(error => {
        // error catching
        if (error.response) {
          this.setState({status: "error", err: error.response.data});
        } else if (error.request) {
          this.setState({status: "error", err: "No Response"});
          console.log(error.request);
        } else {
          this.setState({status: "error", err: "Error with Request"});
          console.log('Error', error.message);
        }
      });
  }

  render() {
    if (this.state.status === "Error") {
      return (
        <h2>{this.state.err}</h2> 
      ) // If error, show error
    } else {
      // Create a button, which looks like a delete icon, which when clicked, sends the delete request
      return (
        <IconButton onClick={this.deleteThing} id={"delete-" + this.props.id.toString()} name={"delete-"+this.props.name.replace(/\s+/g, '-').toLowerCase()}><DeleteIcon /></IconButton>
      )
    }
  }
}

export default LeagueList;
----

==== Errors at this stage
There were numerous errors at this stage, some harder to fix than others.

===== Enter to submit
When using the add league form, the form, could not be submitted by pressing enter.
This can be fixed by instead of button.

[source,jsx]
----
+ <Button type={"submit"} variant={"raised"} color={"primary"} className={"submitForm"}>Submit</Button>

+ <form className={"theLeagueForm"} onSubmit={this.submit}>

- <form className={"theLeagueForm"}>

- <Button onClick={this.submit} variant={"raised"} color={"primary"} className={"submitForm"}>Submit</Button>
----

This now means that the form is additionally submitted with enter.

===== Second time lucky redirects
There was a really peculiar error, causing this in the testing.

2 tests, 1 failed, 1 errors,
[cols="2,2,1,1",options="header",]
|======================================
|Classname |Name |Time |Assertions
|TestLeague |Test adding leagues |7.204 |3
4+|Testing if element <.Leagues> contains text: "nightwatch". Element could not be located.
|None |None |None |None
|TestLeague |Test removing leagues |None |None
|TestLeague | |7.204  |
|======================================

To fix this I tried to find an example from react docs and compare. I noticed that there was an
`event.preventDefault()`, so this was added to the start of `submit` and it stopped happening.
It appears that the default behaviour in some way blocked the first redirect.

===== Button imports
Inputs are condensed in the writeup, for the buttons I am using material-ui, because the buttons look nice, and I
intend to eventually fit the rest of the page to material design. `import {Button, TextField} from 'material-ui';`
is the import in the js. But before it was `import Button from 'material-ui';` this was importing the entirity of
material-ui and calling it Button. This was not a valid component and caused

----
warning.js:33 Warning: React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component  from the file it's defined in. Check the render method of `AddLeague`. +
    in AddLeague (created by Route) +
    in Route (created by App) +
    in div (created by App) +
    in Router (created by BrowserRouter) +
    in BrowserRouter (created by App) +
    in App
----

===== Calling incorrect API path
Sometimes typographical errors can be annoying, I had a request towards the wrong path, this caused permanent loading
and also caused a 404 error on the get request, it also complained due to content being empty it cannot map undefined.

This was easily fixed by changing `/api/legue/` to `/api/league`

===== Material-ui changes
When using early versions of libraries, the components are sometimes subject to change. On a new version of material-ui
buttons changed, this cause buttons to look different and log an error saying +
[red]#Warning: Unknown prop `raised` on <button> tag. Remove this#

.Image of button
image::error-pictures/wrong-button.png[]

This was fixed by `<Button raised />` => `<Button variant="raised">`.

===== 404 on paths
Home controller didn't have all the routes, so when not linked through js, the backend would say it doesnt exist and show.

.404 error
image::error-pictures/404-page.png[]

[source, java]
----
@RequestMapping(value = {"/league/*/add-team", "/league/*/add-game", "league/*", "/", "/add/league", "/league", "/player/*", "/team/*", "/team/*/add-player"})
    public String index(){
        return "index";
    }
----

This added all current and soon to be added routes, so that this would no longer be a problem.

=== Team Controller
Adding teams was fairly similar to adding leagues.

==== TeamControllerTest.java
This is very similar to LeagueControllerTest as both do similar things.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@RunWith(MockitoJUnitRunner.class)
// This runs the tests with a testRunner, this allows assertions which would otherwise be not allowed
public class TeamControllerTest {

    @Mock
    private TeamRepository repo;
    // Create a mocked TeamRepository, doesn't do anything which I don't tell it to do explicitly
    @Mock
    private LeagueRepository leagueRepository;
    // Create a mocked leagueRepository
    private MockMvc mockMvc;
    // Needs a MockMvc to send requests to test the app

    @Before
    public void setUp() {
        mockMvc = MockMvcBuilders.standaloneSetup(new TeamController(repo, leagueRepository)).build();
        // Create the TeamController
    }

    @Test
    public void addTeam_shouldSaveTheTeam() throws Exception {
        League league = new League(1L, "Brian",  new LinkedList<>());
        // Create a league
        Team team = new Team(1L, "Brian", null, null, league);
        // Add a team to the league
        when(repo.save(isA(Team.class))).thenReturn(team);
        when(repo.findOne(team.getId())).thenReturn(team);
        // When I save, or try to find the team, return the team
        when(repo.findAll()).thenReturn(Collections.singletonList(team));
        // When I try to find all teams, return a list of teams
        when(leagueRepository.findOne(league.getId())).thenReturn(league);
        // When I try to find the league, return the league

        String uri = mockMvc.perform(post("/api/team")
                // Send a post request to /api/team
                .content("{\"name\":\"Brian\", \"leagueId\": \"1\"}")
                // Send this
                .contentType("application/json"))
                // With contentType: 'application/json' header
                .andExpect(status().isCreated())
                // Expect a 201
                .andExpect(header().string("Location", "http://localhost:8080/api/team/" + team.getId()))
                // Expect a header called location with the location of the team
                .andReturn().getResponse().getHeader("Location");
                // Return the location

        mockMvc.perform(get(uri))
                // Send a get request to location returned from post
                .andExpect(status().isOk())
                // Expect 200
                .andExpect(MockMvcResultMatchers.jsonPath("$.name", equalTo("Brian")))
                .andExpect(MockMvcResultMatchers.jsonPath("name", equalTo("Brian")));
                // Expect it has the name Brian, like the team
    }

    @Test
    public void deleteTeam_shouldDeleteTeam() throws Exception {
        League league = new League(1L, "Brian", new LinkedList<>());
        Team team = new Team(1L, "Brian", null, null, league);
        Team team2 = new Team(2L, "Dave", null, null, league);
        league.addTeam(team);
        league.addTeam(team2);

        // Create the objects again

        doNothing().when(repo).delete(isA(Long.class));
        // When I delete something, do nothing
        when(repo.findOne(team.getId())).thenReturn(team);
        // When I try to find a team, return the team

        mockMvc.perform(delete("/api/team/1"))
                // Send a delete request to the team
                .andExpect(status().isNoContent());
                // Expect a 204 returned


        verify(repo, times(1)).delete(1L);
        // Check that delete attempted
        assertThat(league.getTeams()).doesNotContain(team);
        assertThat(league.getTeams()).contains(team2);
        // Check it removed itself, but not the other team from league
    }
}
----

==== TeamRest.java
We can't just send a full Team, sadly relational databases are complicated like that. So we use a simpler class we can
use to construct a Team.

[source, java]
----
package com.saskcow.bowling.rest;

import ...

@Data
// Getters and Setters and more all done
@NoArgsConstructor
// Can make one with nothing
@AllArgsConstructor
// Can make one with everything
public class TeamRest {
    private String name;
    private Long leagueId;
}
----

This we can construct with the following JSON from the front end.

[source, json]
----
{
    "name": "Team Name",
    "leagueId": 314
}
----

This makes it easy to construct from the JSON if we say that what we are sent is this.

==== TeamController.java
The controller which maps /api/team requests as the tests expected.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

import java.net.URI;

@Controller
public class TeamController {

    private TeamRepository repo;
    private LeagueRepository leagueRepository;
    // Needs a TeamRepository and a LeaguRepository

    @Autowired
    // Gets it from application context and injects automatically
    public TeamController(TeamRepository repo, LeagueRepository leagueRepository){
        this.repo = repo;
        this.leagueRepository = leagueRepository;
    }
    // Create a TeamController with stuff from application context

    @RequestMapping(value = "/api/team/{id}", method = RequestMethod.GET)
    // Any get requests to /api/team/id calls this function
    public ResponseEntity<TeamView> findTeam(@PathVariable("id") Long id) {
        Team team = repo.findOne(id);
        // Get the Team
        TeamView teamView = new TeamView(team);
        // Make it a TeamView
        return ResponseEntity.ok(teamView);
        // Send it back with a 200
    }

    @RequestMapping(value = "/api/team", method = RequestMethod.POST)
    // Any post requests to /api/team call this function
    public ResponseEntity<?> saveTeam(@RequestBody TeamRest team) {
        // Take the JSON payload as a TeamRest called team
        League league = leagueRepository.findOne(team.getLeagueId());
        // Get the league
        Team savedTeam = repo.save(new Team(team.getName(), league));
        // Save a new Team with name of JSON and league of what we just got
        league.addTeam(savedTeam);
        // Add Team to the League
        leagueRepository.save(league);
        // Save League changes
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest().path("/{id}")
                .buildAndExpand(savedTeam.getId()).toUri();
        // Create a URI with the location
        return ResponseEntity.created(location).build();
        // Return location header with a 201
    }

    @RequestMapping(value = "/api/team/{id}", method = RequestMethod.DELETE)
    public ResponseEntity<Void> deleteTeam(@PathVariable("id") Long id) {
        try {
            Team team = repo.findOne(id);
            // Get the team
            team.getLeague().deleteTeam(team);
            // Remove team from league
            repo.delete(id);
            // Delete the team
            return ResponseEntity.noContent().build();
            // Return 204
        } catch (ResourceNotFoundException e) {
            return ResponseEntity.notFound().build();
            // If not found, send a 404
        }
    }
}

----

==== TeamView.java
In the same way it's hard to send relational objects as JSON due to infinite recursion, we need a simpler way of sending it.

[source, java]
----
package com.saskcow.bowling.view;

import ...

@Data
@NoArgsConstructor
// We've seen these enough now
public class TeamView {
    private LeagueViewSummary league;
    // Get a simplified league
    private Long id;
    private String name;
    // Get the team id and name
    private List<PlayerViewSummary> players;
    private List<GameView> games;
    // Get players and games as View objects


    public TeamView(Team team) {
        this.league = new LeagueViewSummary(team.getLeague());
        this.name = team.getName();
        this.id = team.getId();
        this.players = team.getPlayers() == null ? null : team.getPlayers().stream().map(PlayerViewSummary::new).collect(Collectors.toList());
        this.games = team.getGames()== null ? null : team.getGames().stream().map(GameView::new).collect(Collectors.toList());
        // Make all games into GameView and all teams into TeamViewSummary
    }
    // Get all the values from a team it was created with
}

----

Makes it into JSON like

[source, json]
----
{
    "league": {
        "id": 1,
        "name": "City Watch"
    },
    "id": 3,
    "name": "The Night Watch",
    "players": [
        {
            "id": 5,
            "name": "Sam Vimes"
        },
        {
            "id": 6,
            "name": "Carrot Ironfoundersson"
        },
        {
            "id": 7,
            "name": "Nobby Nobbs"
        },
        {
            "id": 8,
            "name": "Fred Colon"
        }
    ],
    "games": [
        {
            "id": 13,
            "time": "2018-04-15T15:54:53",
            "teams": [
                {
                    "id": 3,
                    "name": "The Night Watch"
                },
                {
                    "id": 4,
                    "name": "Cable Street Particulars"
                }
            ],
            "venue": "The Shades",
            "league": {
                "id": 1,
                "name": "City Watch"
            }
        }
    ]
}
----

TIP: JSON from a later version with all the view objects

==== TeamViewSummary.java
A simplified teamView for when other objects don't care about the details

[source, java]
----
@Data
@NoArgsConstructor
public class TeamViewSummary {
    private Long id;
    private String name;
    // Only needs id and name

    public TeamViewSummary(Team team) {
        this.name = team.getName();
        this.id = team.getId();
    }
    // Get values from the team
}
----

Nice and simple, sends like

[source, json]
----
{
    "id": 3,
    "name": "The Night Watch"
}
----

==== Errors at this stage
This was fairly similar to the previous league controller creation, so few errors occured.

===== @RunWith importance
Upon writing tests, I forgot to add the @RunWith annotation.
This caused the following,

.No @RunWith annotation
image::error-pictures/no-runwith.png[noRunWith,pdfwidth=100%]

This was easily rectified by adding the annotation

===== Need View Objects
Now that leagues have teams, and teams have leagues, sending back the league or team causes a stack overflow as both
contain references to the other, therefore we require the view objects.

=== Team front end
Now the back end for teams is done, we need to give a league some teams, and be able to add and display more detail on these teams.

==== League.js
Leagues now have teams, let's show that.

[source, jsx]
----
// Added to return (
<h3>Teams</h3>
<ul className={"Teams"}>
  {/*Create a list of all the teams*/}
  {this.state.teams.map(team => (
    <TeamSummary key={team.id} id={team.id}>{team.name}</TeamSummary> {/*There are no teams, so this is just blank*/}
  ))}
</ul>
<Link to={"/league/" + this.state.id + '/add-team'}><Button className={"addTeam"} variant={"raised"} color={"primary"}>Add A Team</Button></Link>
{/*Link to the add a team to the league page*/})
----

This allows the league to show a list of its teams.

==== App.js
We need routes to add and show teams.

[source, jsx]
----
(<Router>
  {/*React Router BrowserRouter which creates a router which can have routes here*/}
  <div className="App">
    {/*Following added*/}
    <Route exact path="/team/:id" component={Team}/>
    {/*at /team/{id} show Team page*/}
    <Route path={"/league/:id/add-team"} component={AddTeam}/>
    {/*at /league/{id}/add-team show the add team to league page*/}
  </div>
</Router>)
----

==== AddTeam.js
Page to add teams to league id specified in URL

[source, jsx]
----
import ...

// Create component AddTeam
class AddTeam extends React.Component {
  constructor(props) {
    super();
    // calling super makes this work, as in the keyword this, like on the next line
    this.state = ({name: "No Name", leagueId: props.match.params.id});
    // Set default state
    this.submit = this.submit.bind(this);
    this.updateName = this.updateName.bind(this);
    // Bind this to these functions, allows them to access this, again the keyword
  }

  submit(event) {
    // Take an event, like an onClick or onChange on a Component
    event.preventDefault();
    // Stops normal way of doing it, so it can be overridden by doing this
    axios.post("/api/team", {name: this.state.name, leagueId: this.state.leagueId})
      // Send a post request with the JSON based off of state
      .then(response => {
        window.location.href = '/league/' + this.state.leagueId;
        this.state.name = "";
        console.log("created at " + response.headers.location);
        // Redirect to /league/id and reset variables in case redirect has problems
      })
      .catch(function (error) {
        console.log(error);
        // If something goes wrong, log it in developer console (f12 on most browsers)
      });
  }

  updateName(event) {
    this.setState({name: event.target.value})
    // Take an event and set name to the value of the Component which sent the event
  }

  render() {
    // when shown on screen
    return (
      <div className={"AddScreen"}>
        {/*Contain in a div, as it has to return one Component*/}
        <h1>Add a Team to the League!</h1>
        <form className={"theTeamForm"} onSubmit={this.submit}>
          {/*When form submitted call submit with event*/}
          <TextField
            id="TeamName"
            label="Team Name"
            placeholder="Team Name"
            className={"TeamNameInput"}
            onChange={this.updateName}
          /> <br />
          {/*Create a text field with labels and when changed calls updateName*/}
          <Button type={"submit"} variant={"raised"} color={"primary"} className={"submitForm"}>Submit</Button>
          {/*Form submit button*/}
        </form>
      </div>
    )
  }
}

export default AddTeam // Export AddTeam for easy imports;
----

==== TeamSummary.js
Simple version to show in the lists of other objects like League.js

[source, jsx]
----
import ...

class TeamSummary extends React.Component {
  render() {
    // When displayed
    return (
      <li className={this.props.children.replace(/\s+/g, '-').toLowerCase()}>
        {/*Create a list element with a class all lower cases with " " => "-"*/}
        <Link to={'/team/' + this.props.id.toString()}>
          {/*Link to the team page*/}
          {this.props.children}
          {/*Team name*/}
        </Link>
        <Delete id={this.props.id} type={'team'} name={this.props.children}/>
        {/*Use the delete object from earlier*/}
      </li>
    )
  }
}

export default TeamSummary // Export for easy imports;
----

==== Team.js
A page to see details of the team, currently not much

[source, jsx]
----
import ...

class Team extends React.Component {

  constructor(props) {
    super();
    this.state = {status: "Loading"};
    this.getTeam = this.getLeague.bind(this);
    this.getTeam(props.match.params.id);
    // Start by getting team details
  }

  getTeam(id) {
    axios.get('/api/team/' + id)
    // Send a get request to /api/team/ + the id in the page url
      .then(response => {
        this.setState({
          status: "OK",
          id: id,
          name: response.data.name,
          league: response.data.league,
          players: response.data.players
        })
        // Map response to state
      })
      .catch(error => {
        this.setState({status: "error", err: "problem getting team"})
        console.log(error)
      });
  }

  render() {
    if(this.state.status === "OK") {
      return (
        <div className={'Team'}>
          {/*Contain in Team div*/}
          <h2>{this.state.name}</h2>
          <Link to={"/league/" + this.state.league.id}>{this.state.league.name}</Link>
          {/*Link back to league*/}
        </div>
      )
    } else if (this.state.status === "error") {
      return (
        <h2>{this.state.err}</h2>
      )
      // Display any error in request
    } else {
      return <CircularProgress color={"primary"} />
    } // Loading icon
  }
}

export default Team;
----

==== Errors at this stage

===== Error logging
Ironically the error on request logging originally tried reading error values such as `error.response.status`,
however these were sometimes null. This caused null pointer exceptions when trying to handle errors.

This was fixed by simply stating an error has occurred and doing `console.log(error)`.

=== Nightwatch Testing
Well, using a webpage takes time, time which I could be spending watching something else use my website,
therefore to save me from the pain of actually doing work, I did this.

==== nightwatch.json
This is basically a configuration file for nightwatch, I got the default off of the internet and added what I needed.

[source, json]
----
{
  "src_folders" : ["src/test/js"],
  "output_folder" : "reports/data",
  "custom_commands_path" : "",
  "custom_assertions_path" : "",
  "page_objects_path" : "",
  "globals_path" : "",

  "selenium" : {
    "start_process" : true,
    "server_path" : "./node_modules/selenium-standalone/.selenium/selenium-server/3.9.1-server.jar",
    "log_path" : "",
    "port" : 4444,
    "cli_args" : {
      "webdriver.chrome.driver" : "./node_modules/selenium-standalone/.selenium/chromedriver/2.35-x64-chromedriver"
    }
  },

  "test_settings" : {
    "default" : {
      "launch_url" : "http://localhost",
      "selenium_port"  : 4444,
      "selenium_host"  : "localhost",
      "silent": true,
      "desiredCapabilities": {
        "browserName": "chrome"
      },
      "screenshots" : {
        "enabled" : true,
        "path" : "./reports/screenshots/errors",
        "on_failure": true
      }
    }
  }
}
----
src_folders is where the tests are, output is where the logs go. +
test_settings mostly say take screenshots and use chrome.

==== TestLeague.js
Now we have the immense functionality of adding some leagues, and then give them some teams, we now need to test, just the league bit here.

[source, jsx]
----
module.exports = {
  // Export this
  'Test adding leagues' : function (browser) {
    // Create a test called Test adding leagues and it's a function which takes a browser
    let directory = "./reports/screenshots/TestLeague/";
    // Set image directory
    browser
      .url('http://user:saskcow@localhost:8080/league')
      // Set url to /league on page, authenticate with basic auth if necessary
      .pause(1000)
      // Wait 1000ms for it to load
      .waitForElementVisible('body', 1000)
      // Check if <body> turns up in the next 1000 ms
      .saveScreenshot(directory + "1-start.png")
      // Save a screenshot of the page in the image directory
      .click('button[class~=add]')
      // Click the <button> which has class containing add
      // This is a CSS selector and is what one would use in CSS to set styles for elements
      .waitForElementVisible('input[id=LeagueName]', 1000)
      // Wait 1000ms for an input for LeagueName to be visible
      .setValue('input[id=LeagueName]', 'nightwatch')
      // Write nightwatch in the input box
      .saveScreenshot(directory + "2-adding a league.png")
      // Save a screenshot
      .click('button[class~=submitForm]')
      // Click the submit button
      .pause(1000)
      // Wait for page to load
      .assert.containsText('.Leagues', 'nightwatch')
      // Make sure .Leagues (component with class Leagues) contains the text nightwatch
      // This will confirm that the team is there
      .saveScreenshot(directory + "3-Shows League.png")
      // Save another screenshot
      .click('button[class~=add]')
      // Click add button again
      .waitForElementVisible('input[id=LeagueName]', 1000)
      .setValue('input[id=LeagueName]', 'daywatch')
      .click('button[class~=submitForm]')
      .pause(1000)
      .assert.containsText('.Leagues', 'daywatch')
      .saveScreenshot(directory + "4-Second League.png")
      // Repeat the add and check processes

  },

  'Test removing leagues' : function (browser) {
    // Create a new testCase which deletes leagues
    let directory = "./reports/screenshots/TestLeague/";
    browser
      .click('button[name=delete-daywatch]')
      .pause(1000);
    // Click the delete daywatch button
    browser.expect.element('.Leagues').text.to.not.contain('daywatch');
    browser.expect.element('.Leagues').text.to.contain('nightwatch');
    // Expect .Leagues to still have nightwatch, but not daywatch
    browser
      .saveScreenshot(directory + "5-Deleted daywatch.png")
      .click('button[name=delete-nightwatch]')
      .pause(1000);
    // Delete nightwatch anyway, after of course another screenshot
    browser.expect.element('.Leagues').text.to.not.contain('nightwatch');
    // Check nightwatch isn't there
    browser
      .end();
      // Close browser
  }
};
----

See, far easier than doing it manually 100 odd times, checks I haven't broken anything too bad

==== TestTeams.js
Well Teams exist, so those should be tested, so this is the test.

[source, jsx]
----
module.exports = {
  // Export this
  'Setup' : function (browser) {
  // Create testCase Setup
    let directory = "./reports/screenshots/TestTeams/";
    browser
      .url('http://user:saskcow@localhost:8080/league')
      .pause(1000)
      .waitForElementVisible('body', 1000)
      .click('button[class~=add]')
      .waitForElementVisible('input[id=LeagueName]', 1000)
      .setValue('input[id=LeagueName]', 'Nights Watch')
      .click('button[class~=submitForm]')
      .pause(1000)
      .assert.containsText('.Leagues', 'Nights Watch')
      .saveScreenshot(directory + "1-init league.png")
      // Follow procedure to create a team from last time, just less screenshots this time
  },

  'Test Adding Teams' : function (browser) {
    let directory = "./reports/screenshots/TestTeams/";
    browser
      .click('li[class=nights-watch]>a')
      // Click on the <a> inside the <li> with Nights Watch
      .pause(1000)
      // Pause for effect, and load times
      .assert.containsText('h2', 'Nights Watch')
      // Check the header says Nights Watch
      .saveScreenshot(directory + "2-League view.png")
      // Everyone wants to see this empty team, so we screenshot it

      .click('button[class~=addTeam]')
      // Click add Team button
      .waitForElementVisible('input[id=TeamName]', 1000)
      // Wait till input visible
      .setValue('input[id=TeamName]', 'Sam Vimes')
      // Enter Name into box, ignore that Sam Vimes is usually a person, not a team
      .saveScreenshot(directory + "3-Add Team screen.png")
      .click('button[class~=submitForm]')
      // Submit form
      .pause(1000)
      .assert.containsText('.Teams', 'Sam Vimes')
      // Check Teams includes Sam Vimes
      .saveScreenshot(directory + "4-Sam Vimes in the watch.png")

      .click('button[class~=addTeam]')
      .waitForElementVisible('input[id=TeamName]', 1000)
      .setValue('input[id=TeamName]', 'Findthee Swing')
      .click('button[class~=submitForm]')
      .pause(1000)
      // Make another team, also a person, who isn't in Night Watch, called Findthee Swing

      .assert.containsText('.Teams', 'Sam Vimes')
      .assert.containsText('.Teams', 'Findthee Swing')
      .saveScreenshot(directory + "5-2 teams.png")
      // Check Vimes is still there and that Swing is now
  },

  'Deleting' : function (browser) {
    let directory = "./reports/screenshots/TestTeams/";
    browser
      .click('button[name=delete-findthee-swing]')
      // Delete Swing
      .pause(1000);
    browser.expect.element('.Teams').text.to.not.contain('Findthee Swing');
    browser.expect.element('.Teams').text.to.contain('Sam Vimes');
    // Check Vimes is there, Swing isn't
    browser
      .saveScreenshot(directory + "6-Deleted swing.png")
      .click('button[name=delete-sam-vimes]')
      .pause(1000);
    browser.expect.element('.Teams').text.to.not.contain('Sam Vimes');
    // Delete Vimes nad check he isn't there
    browser
      .url('http://localhost:8080/league')
      .click('button[name=delete-nights-watch]')
      .pause(1000);
    browser.expect.element('.Leagues').text.to.not.contain('Nights Watch');
    // Delete League nad check it's really gone
    browser.end(); // close browser
  }
};
----

==== Tests at this point

include::test/1. Teams Work.adoc[]

==== Errors at this stage
CSS selectors are hard, so that took a while and sometimes patience is required to correctly assert.

===== Not waiting long enough
Sometimes the page hasn't loaded, so an element isn't seen, this can cause a click to fail, causing errors down the line
as the test gets lost.

To fix this many `.pause(1000)` were put in after any redirects to ensure it doesn't end up missing something.

===== Incorrect CSS selector
CSS Selectors can be easy to have the wrong elements checked resulting in errors such as this.

.Expected visible, but not found
image::error-pictures/expected-visible.png[noRunWith,pdfwidth=100%]

One example was `li[class=name] => li[class~=name] as it had other classes too, so this was necessary

Others include mistyping classes or ids in selectors.

=== Player Controller
Teams have players, as do games, so it seems a good place to go next. Again it'll start with tests then continue onwards.

==== PlayerControllerTest.java
 This will be very similar to Team Controller as it does similar things.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@RunWith(MockitoJUnitRunner.class)
public class PlayerControllerTest {

    @Mock
    private PlayerRepository repo;
    @Mock
    private TeamRepository teamRepository;
    private MockMvc mockMvc;

    @Before
    public void setUp() {
        mockMvc = MockMvcBuilders.standaloneSetup(new PlayerController(repo, teamRepository))
                .build();
    }

    @Test
    public void addPlayer_shouldSaveThePlayer() throws Exception {
        Team team = new Team(1L, "Brian's Bowlers!", new LinkedList<>(),null, null);
        Player player = new Player(1L, "Brian", team);
        // Create a team and a player, which isn't yet added to the team

        when(repo.save(isA(Player.class))).thenReturn(player);
        when(repo.findOne(player.getId())).thenReturn(player);
        when(repo.findAll()).thenReturn(Collections.singletonList(player));
        // Mock methods to return player when repo would return player

        when(teamRepository.findOne(team.getId())).thenReturn(team);
        // Mock to return team when team found in teamRepository

        String uri = mockMvc.perform(post("/api/player")
                // Send a post request to /api/player
                .content("{\"name\":\"Brian\", \"teamId\": \"1\"}")
                // with this data
                .contentType("application/json"))
                // and this content-type header
                .andExpect(status().isCreated())
                // Expect a 201
                .andExpect(header().string("Location", "http://localhost:8080/api/player/" + player.getId()))
                // Expect Location to have path to object
                .andReturn().getResponse().getHeader("Location");
                // Return object

        mockMvc.perform(get(uri))
                // Send a get request to the returned uri
                .andExpect(status().isOk())
                // Expect 200
                .andExpect(MockMvcResultMatchers.jsonPath("$.name", equalTo("Brian")))
                .andExpect(MockMvcResultMatchers.jsonPath("name", equalTo("Brian")));
                // Expect Player Name is Brian
    }

    @Test
    public void deletePlayer_shouldDeletePlayer() throws Exception {
        Team team = new Team(1L, "Brian's Bowlers!", new LinkedList<>(),null, null);
        Player brian = new Player(1L, "Brian", team);
        Player dave = new Player(2L, "Dave", team);
        team.addPlayer(brian);
        team.addPlayer(dave);
        // Create a team with 2 players

        doNothing().when(repo).delete(isA(Long.class));
        // when repo delete called, do nothing
        when(repo.findOne(brian.getId())).thenReturn(brian);
        // when Player brian found in repo, return him

        mockMvc.perform(delete("/api/player/1"))
                // Send the order to "delete" brian
                .andExpect(status().isNoContent());
                // Expect no content

        verify(repo, times(1)).delete(1L);
        // Check the act was done
        assertThat(team.getPlayers()).doesNotContain(brian);
        assertThat(team.getPlayers()).contains(dave);
        // Check dave didn't swap with brian, and is still there
    }
}
----

==== PlayerController.java
Also similar to TeamController, but this one routes Player requests not Team requests.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@Controller // It's a controller, send requests here
public class PlayerController {

    private PlayerRepository repo;
    private TeamRepository teamRepository;
    // Has a PlayerRepository and a TeamRepository

    @Autowired
    public PlayerController(PlayerRepository repo, TeamRepository teamRepository){
        this.repo = repo;
        this.teamRepository = teamRepository;
    }
    // Create one with a PlayerRepository and a TeamRepository from application context

    @RequestMapping(value = "/api/player/{id}", method = RequestMethod.GET)
    // Get requests to /api/player/{id} call this function
    public ResponseEntity<PlayerView> findPlayer(@PathVariable("id") Long id) {
        Player player = repo.findOne(id);
        PlayerView playerView = new PlayerView(player);
        // Get a player, then make it a PlayerView
        return ResponseEntity.ok(playerView);
        // Return a 200 with the playerView
    }

    @RequestMapping(value = "/api/player", method = RequestMethod.POST)
    // Post requests to /api/player/ call this function
    public ResponseEntity<?> savePlayer(@RequestBody PlayerRest player) {
        // Get PlayerRest from JSON sent
        Team team = teamRepository.findOne(player.getTeamId());
        // Get the team from the teamId in playerRest
        Player savedPlayer = repo.save(new Player(player.getName(), team));
        // Save new Player with name and team
        team.addPlayer(savedPlayer);
        // Add to the team
        teamRepository.save(team);
        // Save the team
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest().path("/{id}")
                .buildAndExpand(savedPlayer.getId()).toUri();
        // Get the URI where one could retrieve this object
        return ResponseEntity.created(location).build();
        // Send the location as a header with a 200
    }

    @RequestMapping(value = "/api/player/{id}", method = RequestMethod.DELETE)
    // Delete requests to /api/player/{id} call this function
    public ResponseEntity<Void> deletePlayer(@PathVariable("id") Long id) {
        // Take the id from uri
        try {
            Player player = repo.findOne(id);
            player.getTeam().deletePlayer(player);
            // Remove the specified player from the team
            repo.delete(id);
            // Delete the player
            return ResponseEntity.noContent().build();
            // Return 204
        } catch (ResourceNotFoundException e) {
            return ResponseEntity.notFound().build();
            // If you can't find the player, send a 400
        }
    }
}

----

==== PlayerRest.java
We need to make players now, and the conventional methods don't send well in JSON.
So this'll have to do.

[source, java]
----
package com.saskcow.bowling.rest;

import ...

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PlayerRest {
    private String name;
    private Long teamId;
}
----

So it takes JSON

[source, json]
----
{
  "name": "Player Name",
  "teamId": 314
}
----

==== PlayerView.java
Now we need to view the player, as irritatingly enough sending back objects with these references still causes StackOverflow.

[source, java]
----
package com.saskcow.bowling.view;

import ...

@Data
@NoArgsConstructor
public class PlayerView {
    private Long id;
    private TeamViewSummary team;
    private String name;

    public PlayerView(Player player){
        this.id = player.getId();
        this.name = player.getName();
        this.team = new TeamViewSummary(player.getTeam());
    } // Player name and id, but team is a TeamViewSummary now
}

----

==== PlayerViewSummary.java
Once again, a name and an id

[source, java]
----
import ...

@Data
@NoArgsConstructor
public class PlayerViewSummary {
    private Long id;
    private String name;

    public PlayerViewSummary(Player player){
        this.id = player.getId();
        this.name = player.getName();
    }
}
----

==== Errors at this stage

===== Invalid Type

`Player player = new Team(...);` doesn't work as we cannot convert a Team to a Player.
And it should be a Team anyway.

.Incompatible Types
image::error-pictures/incompatible-types.png[invalidType, pdfwidth=100%]

include::test/2. Players back end only.adoc[]

=== Player Front End

==== App.js
Added

[source, javascript]
----
<Route exact path="/player/:id" component={Player}/>
<Route path={"/team/:id/add-player"} component={AddPlayer}/>
----

To give routes for adding and showing Player.

==== Team.js
Included in .Team to display all the players in the team.

[source, jsx]
----
<h3>Players</h3>
{/*Title Players*/}
<ul className={"Players"}>
  {/*Create an unordered list class Players*/}
  {this.state.players.map(player => (
    {/*For every player in this.state.players, return this*/}
    <PlayerSummary key={player.id} id={player.id}>{player.name}</PlayerSummary>
    {/*Make a PlayerSummary for every player in this.state.players*/}
  ))}
</ul>
<Link to={"/team/" + this.state.id + '/add-player'}><Button className={"addPlayer"} variant={"fab"} color={"primary"}><AddIcon /></Button></Link>
{/*Link to the soon to be added add team page.*/}
----

==== AddPlayer.js
We need to add players, so this will call the controller add player.

[source, jsx]
----
import ...

class AddPlayer extends React.Component {
  constructor(props) {
    super();
    this.state = ({name: "No Name", teamId: props.match.params.id});
    this.submit = this.submit.bind(this);
    this.updateName = this.updateName.bind(this);
    // Standard bind this to functions and set default state
  }

  submit(event) {
    event.preventDefault();
    // Prevent normal behaviour of a button
    axios.post("/api/player", {name: this.state.name, teamId: this.state.teamId})
    // Send a post request to /api/player with name and teamId, to match the PlayerRest object
      .then(response => {
        window.location.href = '/team/' + this.state.teamId;
        // Redirect to the team the player was made in
        this.state.name = "";
        console.log("created at " + response.headers.location);
      })
      .catch(function (error) {
        console.log(error);
        // Log any errors
      });
  }

  updateName(event) {
    this.setState({name: event.target.value})
    // On event set this.state.name to value of what sent the event
  }

  render() {
    // When displayed in page
    return (
      <div className={"AddScreen"}>
        {/*Wrap it in a div .AddScreen*/}
        <h1>Add a Team to the League!</h1>
        <form className={"thePlayerForm"} onSubmit={this.submit}>
          {/*Create a form which calls submit when submitted*/}
          <TextField
            id="PlayerName"
            label="Player Name"
            placeholder="Player Name"
            className={"PlayerNameInput"}
            onChange={this.updateName}
          /> <br />
          {/*Text input which calls updateName when changed with label PlayerName*/}
          <Button type={"submit"} variant={"raised"} color={"primary"} className={"submitForm"}>Submit</Button>
          {/*Call submit*/}
        </form>
      </div>
    )
  }
}

export default AddPlayer;
----

==== PlayerSummary.js
Team needs to show players, with PlayerSummarys, so we implement them.

[source, jsx]
----
import {Link} from "react-router-dom";

class PlayerSummary extends React.Component {
  render() {
    return (
      <li className={this.props.children.replace(/\s+/g, '-').toLowerCase()}>
        {/*Return a list element with class of player name*/}
        <Link to={'/player/' + this.props.id.toString()}>
          {this.props.children}
        </Link>
        {/*Link to player page*/}
        <Delete id={this.props.id} type={'player'} name={this.props.children}/>
        {/*Delete Button*/}
      </li>
    )
  }
}

export default PlayerSummary;
----

==== Player.js
Display more details of the player.

[source, jsx]
----
import ...

class Player extends React.Component {

  constructor(props) {
    super();
    this.state = {status: "Loading"};
    this.getLeague = this.getLeague.bind(this);
    this.getLeague(props.match.params.id);
    // Set default state, bind this to getLeague and getLeague
  }

  getLeague(id) {
    axios.get('/api/player/' + id)
      // Send a get request to playerController and get the player details
      .then(response => {
        this.setState({
          status: "OK",
          id: id,
          name: response.data.name,
          team: response.data.team
          // Map response to state
        })
      })
      .catch(error => {
        console.log(error)
        // Simple error logging
      });
  }

  render() {
    if(this.state.status === "OK") {
      return (
        <div className={'Player'}>
          <h2>{this.state.name}</h2>
          <Link to={"/team/" + this.state.team.id}>{this.state.team.name}</Link>
        </div>
        {/*Show a title, and a link back*/}
      )
    } else {
      return <CircularProgress color={"primary"} />
      // If loading show a loading wheel
    }
  }
}

export default Player;
----

==== TestPlayers.js
Now nightwatch is running, we need to add tests to test the new functionality.

[source, js]
----
module.exports = {
  // Export this

  'Setup' : function (browser) {
    // Create TestCase Setup
    let directory = "./reports/screenshots/TestPlayers/";
    browser
      .url('http://user:saskcow@localhost:8080/league')
      .pause(1000)
      .waitForElementVisible('body', 1000)
      .click('button[class~=add]')
      .waitForElementVisible('input[id=LeagueName]', 1000)
      .setValue('input[id=LeagueName]', 'Nights Watch')
      .click('button[class~=submitForm]')
      .pause(1000)
      .assert.containsText('.Leagues', 'Nights Watch')

      .click('li[class=nights-watch]>a')
      .pause(1000)
      .assert.containsText('h2', 'Nights Watch')

      .click('button[class~=addTeam]')
      .waitForElementVisible('input[id=TeamName]', 1000)
      .setValue('input[id=TeamName]', 'Sam Vimes')
      .click('button[class~=submitForm]')
      .pause(1000)
      .assert.containsText('.Teams', 'Sam Vimes')

      .saveScreenshot(directory + "1-init team.png")

      // Makes a League and Team like in the other examples
  },

  'Test Adding Players' : function (browser) {
    let directory = "./reports/screenshots/TestPlayers/";
    browser
      .click('li[class=sam-vimes]>a')
      .pause(1000)
      .assert.containsText('h2', 'Sam Vimes')
      .saveScreenshot(directory + "2-Team view.png")
      // Click on a team, and check it's the right one

      .click('button[class~=addPlayer]')
      .waitForElementVisible('input[id=PlayerName]', 1000)
      // Click add a player and wait for page to load
      .setValue('input[id=PlayerName]', 'Sam Vimes')
      // Set player Name
      .saveScreenshot(directory + "3-Add Player screen.png")
      .click('button[class~=submitForm]')
      .pause(1000)
      // Submit player and wait for page to load
      .assert.containsText('.Players', 'Sam Vimes')
      .saveScreenshot(directory + "4-Sam Vimes in the Vimes.png")
      // Check player exists

      .click('button[class~=addPlayer]')
      .waitForElementVisible('input[id=PlayerName]', 1000)
      .setValue('input[id=PlayerName]', 'Mas Mives')
      .click('button[class~=submitForm]')
      .pause(1000)
      .assert.containsText('.Players', 'Mas Mives')
      .saveScreenshot(directory + "5-2 players.png")
      // Add another player
  },

  'Test Player' : function (browser) {
    let directory = "./reports/screenshots/TestPlayers/";
    browser
      .click('li[class=mas-mives]>a')
      .pause(1000)
      .assert.containsText('h2', 'Mas Mives')
      .assert.containsText('a', 'Sam Vimes')
      .saveScreenshot(directory + "6-Mas Mives.png")
      .click('a')
      // Look at a player, check a name and a back button appears, and leave
      // Players don't have much going for them
  },

  'Deleting' : function (browser) {
    let directory = "./reports/screenshots/TestPlayers/";
    browser
      .click('button[name=delete-mas-mives]')
      .pause(1000);
    browser.expect.element('.Players').text.to.not.contain('Mas Mives');
    browser.expect.element('.Players').text.to.contain('Sam Vimes');
    // Delete Mas Mives and check he's gone
    browser
      .saveScreenshot(directory + "7-Deleted Mives.png")
      .click('button[name=delete-sam-vimes]')
      .pause(1000);
    browser.expect.element('.Players').text.to.not.contain('Sam Vimes');
    // Delete Sam Vimes and check he's gone
    browser
      .url('http://localhost:8080/league')
      .click('button[name=delete-nights-watch]')
      .pause(1000);
    browser.expect.element('.Leagues').text.to.not.contain('Nights Watch');
    // Delete the League
    browser.end();
    // Close the browser
  }
};
----

include::test/3.Players Front and Back.adoc[]

=== Games in Back end
Game is a bit different, teams are a oneToMany with League,
players are a manyToMany with Team,
games have oneToMany with Team and League. Despite this this is still fairly similar.

==== GameControllerTest.java
Got to test the controller to save time later on.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@RunWith(MockitoJUnitRunner.class)
public class GameControllerTest {

    @Mock
    private GameRepository repo;
    @Mock
    private TeamRepository teamRepository;
    // Create a mock GameRepository, TeamRepository
    private MockMvc mockMvc;

    @Before
    public void setUp() {
        mockMvc = MockMvcBuilders.standaloneSetup(new GameController(repo, teamRepository))
                .build();
    }
    // Create a mockMvc Controller from a new GameController with the mock repos

    @Test
    // It's a test, run it with gradle test, and report on it
    public void addGame_shouldSaveTheGame() throws Exception {
        League league = new League(1L, "Brian", null, new LinkedList<>());
        Team team1 = new Team(1L, "Dave", null, new LinkedList<>(), league);
        Team team2 = new Team(2L, "David", null, new LinkedList<>(), league);
        LocalDateTime dateTime = LocalDateTime.now(Clock.systemUTC());
        // Create LocalDateTime from current time
        Game game = new Game(1L, dateTime, "Brian Bowling Centre", new LinkedList<>(Arrays.asList(team1, team2)));

        // Create a bunch of objects which would be there when saving a game

        team1.addGame(game);
        team2.addGame(game);
        league.addTeam(team1);
        league.addTeam(team2);

        // Link some of these together

        when(repo.save(isA(Game.class))).thenReturn(game);
        when(repo.findOne(game.getId())).thenReturn(game);
        when(repo.findAll()).thenReturn(Collections.singletonList(game));
        when(teamRepository.findOne(team1.getId())).thenReturn(team1);
        when(teamRepository.findOne(team2.getId())).thenReturn(team2);

        // Mock what the repository would do, return objects when find attempted

        DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        // Make a formatter which takes a LocalDateTime and makes it an ISO local date time string
        String content = String.format("{\"time\":\"%s\", \"venue\": \"Brian Bowling Centre\", \"teamId1\": \"1\", \"teamId2\": \"2\"}", dateTime.format(formatter));
        // Create the content for the GameRest , time, venue, teamId1, teamId2
        // String.format() swaps the %s for the formatted LocalDateTime String

        String uri = mockMvc.perform(post("/api/game")
                // Send a post request to /api/game
                .content(content)
                // Send the JSON String above
                .contentType("application/json"))
                // Include content-type header
                .andExpect(status().isCreated())
                // Expect 201 returned
                .andExpect(header().string("Location", "http://localhost:8080/api/game/" + game.getId()))
                // Expect header of Location of game
                .andReturn().getResponse().getHeader("Location");
                // Return Location

        mockMvc.perform(get(uri))
                .andExpect(status().isOk())
                // Expect 200
                .andExpect(MockMvcResultMatchers.jsonPath("$.venue", equalTo("Brian Bowling Centre")))
                .andExpect(MockMvcResultMatchers.jsonPath("venue", equalTo("Brian Bowling Centre")))
                // Expect Venue same as set in game, Brian Bowling Centre
                .andExpect(MockMvcResultMatchers.jsonPath("$.league.name", equalTo("Brian")))
                .andExpect(MockMvcResultMatchers.jsonPath("$.time", equalTo(dateTime.format(formatter))));
                // Expect League Name and time to be as in game
    }

    @Test
    public void deleteGame_shouldDeleteGame() throws Exception {
        League league = new League(1L, "Brian", null, new LinkedList<>());
        Team team1 = new Team(1L, "Brian", null, new LinkedList<>(), league);
        Team team2 = new Team(2L, "Brian", null, new LinkedList<>(), league);
        LocalDateTime dateTime = LocalDateTime.now(Clock.systemUTC());
        // Create LocalDateTime from current time
        Game game = new Game(1L, dateTime, "Brian Bowling Centre", new LinkedList<>(Arrays.asList(team1, team2)));
        Game game2 = new Game(2L, dateTime, "Brian Bowling Centre", new LinkedList<>(Arrays.asList(team1, team2)));

        // Create objects which would be in place

        team1.addGame(game);
        team2.addGame(game);
        team1.addGame(game2);
        team2.addGame(game2);
        league.addTeam(team1);
        league.addTeam(team2);

        // Link all the objects

        doNothing().when(repo).delete(isA(Long.class));
        when(repo.findOne(game.getId())).thenReturn(game);

        // When delete attempted do nothing, when findOne of gameId return game

        mockMvc.perform(delete("/api/game/1"))
                // Send Delete request to /api/game/1
                .andExpect(status().isNoContent());
                // Expect 204

        verify(repo, times(1)).delete(1L);
        // Check repo method called once
        assertThat(team1.getGames()).doesNotContain(game);
        assertThat(team1.getGames()).contains(game2);
        // Check that there are no links to game, but still to game2
    }

}
----

==== GameController.java
What requests to /api/game go through, makes, deletes and modifies objects in database.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@Controller
public class GameController {
    private GameRepository repo;
    private TeamRepository teamRepository;

    @Autowired
    public GameController(GameRepository repo, TeamRepository teamRepository){
        this.repo = repo;
        this.teamRepository = teamRepository;
    }

    // The Usual has Repositories, and on start gets them from application context

    @RequestMapping(value = "/api/game/{id}", method = RequestMethod.GET)
    // All get requests to /api/game/{id} calls this function
    public ResponseEntity<GameView> findLeague(@PathVariable("id") Long id) {
        // Returns a ResponseEntity with a GameView, takes id from path
        Game game = repo.findOne(id);
        GameView gameView = new GameView(game);
        // Get the game and
        return ResponseEntity.ok(gameView);
    }

    @RequestMapping(value = "/api/game", method = RequestMethod.POST)
    // All post requests to /api/game/ calls this function
    public ResponseEntity<?> saveLeague(@RequestBody GameRest game) {
        // Returns a ResponseEntity takes JSON as GameRest

        Team team1 = teamRepository.findOne(game.getTeamId1());
        Team team2 = teamRepository.findOne(game.getTeamId2());
        List<Team> teams = new LinkedList<>(Arrays.asList(team1, team2));
        DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        LocalDateTime dateTime = LocalDateTime.parse(game.getTime(), formatter);
        // Find all the objects

        Game savedGame = repo.save(new Game(dateTime, game.getVenue(), teams));
        // Save the game
        team1.addGame(savedGame);
        team2.addGame(savedGame);
        // Tell everything else the Game exists
        teamRepository.save(team1);
        teamRepository.save(team2);
        // Save everything

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest().path("/{id}")
                .buildAndExpand(savedGame.getId()).toUri();
        // Put location in the URI
        return ResponseEntity.created(location).build();
        // Send a 201 with the location
    }

    @RequestMapping(value = "/api/game/{id}", method = RequestMethod.DELETE)
    // All delete requests to /api/game/{id} calls this function
    public ResponseEntity<Void> deleteLeague(@PathVariable("id") Long id) {
        // Return a Response, with nothing
        try {
            Game game = repo.findOne(id);
            game.getTeams().forEach(team -> team.deleteGame(game));
            // For each Team in the Game, remove the link
            repo.delete(id);
            // Delete the Game
            return ResponseEntity.noContent().build();
            // Send a 204
        } catch (ResourceNotFoundException e) {
            return ResponseEntity.notFound().build();
            // If you can't find the game, send back a 404
        }
    }
}
----

==== GameRest.java
Once again, no foreign keys etc from JSON so we compromise.

[source, java]
----
package com.saskcow.bowling.rest;

import ...

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GameRest {
    private String time;
    private String venue;
    private Long rotaId;
    private Long teamId1;
    private Long teamId2;
    // All we need to contruct a Game
}
----

JSON Equivalent

[source, json]
----
{
  "time": "2018-04-16T13:48:16",
  "venue": "The Shades",
  "rotaId": 3,
  "teamId1": 1,
  "teamId2": 4
}
----

==== GameView.java
This is the only view object for a game, as at this stage, there isn't much in a game you don't care about,
which teams are playing, when and where are all fairly crucial. But we need at least one view object,
so this is it!

[source, java]
----
package com.saskcow.bowling.view;

import ...

@Data
@NoArgsConstructor
public class GameView {
    private Long id;
    private String time;
    private List<TeamViewSummary> teams;
    private String venue;
    private LeagueViewSummary league;
    // Has an id, a time, 2 teams, a venue, and details of the league

    public GameView(Game game){
        this.id = game.getId();
        this.time = game.getTime().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        // Get time and format it to ISO local time string
        this.teams = game.getTeams().stream().map(TeamViewSummary::new).collect(Collectors.toList());
        // Make all the teams into TeamViewSummary and collect stream into a list
        this.venue = game.getVenue();
        this.league = new LeagueViewSummary(game.getTeams().get(0).getLeague());
        // Get League from team 1s League
        // Get the things from game
    }
}
----

include::test/4. Games in back end.adoc[]

==== Errors at this stage

===== @NoArgsConstructor Required

Originally the `@NoArgsConstructor` was not on GameRest. And that may sound fine, why would it be empty?
Well as it turns out when converting the JSON, it needs an empty GameRest. That's easy enough to add.

.No noArgsConstructor
image::error-pictures/no-no-args.png[noNoArgs, pdfwidth=100%]

Now with the `@NoArgsConstructor`, which creates an empty constructor, it works.

include::test/4. Games in back end.adoc[]

=== Games in the front end

==== App.js
Now we have the standard rewrite the router, we need to add the game and addGame pages.

[source, jsx]
----
(<Route exact path="/" component={LeagueList}/>
<Route exact path="/league" component={LeagueList}/>
<Route exact path="/league/:id" component={League}/>
<Route exact path="/team/:id" component={Team}/>
<Route exact path="/player/:id" component={Player}/>
<Route path={"/league/:id/add-team"} component={AddTeam}/>
<Route path={"/league/:id/add-game"} component={AddGame}/>
<Route path={"/team/:id/add-player"} component={AddPlayer}/>
<Route path="/add/league" component={AddLeague}/>)
// Added to <Router>
----

Routes are now this, this will be like this for a while.

==== League.js
Games need to show somewhere, so a League can show all the games.

[source, jsx]
----
(<h3>Games</h3>
<ul className={"Games"}>
  {this.state.games.map(game => (
    <GameSummary key={game.id} id={game.id} time={game.time} teams={game.teams}>{game.venue}</GameSummary>
  ))}
</ul>
<Link to={"/league/" + this.state.id + '/add-game'}><Button className={"addGame"} variant={"raised"} color={"primary"}>Add A Game</Button></Link>)
// Added to main part of render
----

==== AddGame.js
Now with more menus than ever (more than just a name) we have the next generation of add screen, AddGame.js!

[source, jsx]
----
import ...

class AddGame extends React.Component {
  constructor(props) {
    super();
    this.state = ({status: "Loading", time: new Date().toISOString().slice(0, -5)});
    // set default state, slice end of time string to remove the time zone part
    this.submit = this.submit.bind(this);
    this.updateVenue = this.updateVenue.bind(this);
    this.updateTime = this.updateTime.bind(this);
    this.updateTeam1 = this.updateTeam1.bind(this);
    this.updateTeam2 = this.updateTeam2.bind(this);
    this.getLeague = this.getLeague.bind(this);
    this.getLeague(props.match.params.id);
    // bind this to most things, and then getLeague
  }

  submit(event) {
    event.preventDefault();
    // Prevent standard event behaviour
    axios.post("/api/game", {
      venue: this.state.venue,
      time: this.state.time,
      teamId1: this.state.team1,
      teamId2: this.state.team2,
      rotaId: this.state.rota
      // Send all this off as a GameRest style bit of JSON
    })
      .then(response => {
        window.location.href = '/league/' + this.state.id;
        this.state.name = "";
        console.log("created at " + response.headers.location);
        // Go to league page if done
      })
      .catch(function (error) {
        console.log(error);
        // log any errors into console
      });
  }

  getLeague(id) {
    axios.get('/api/league/' + id)
    // Send get request to /api/league/{id} to get league data, says which teams there are etc.
      .then(response => {
        this.setState({
          id: id,
          status: "OK",
          teams: response.data.teams,
          leagueName: response.data.name,
          team1: response.data.teams[0].id,
          team2: response.data.teams[1].id,
          rota: response.data.rotaId
          // Map response to state
        })
      })
      .catch(error => {
        console.log(error)
        // Log any errors in console
      });
  }

  updateVenue(event) {
    this.setState({venue: event.target.value});
  }

  updateTime(event) {
    console.log(event.target.value);
    this.setState({time: event.target.value});
  }

  updateTeam1(event) {
    this.setState({team1: event.target.value});
  };

  updateTeam2(event) {
    this.setState({team2: event.target.value});
  };

  // All these just update state as sent an event, like all the others, but there are 4 this time

  render() {
    if(this.state.status === "OK") {
      // If loaded
      return (
        <div className={"AddScreen"}>
          <h1>Add game {this.state.name} to {this.state.leagueName}!</h1>
          <form className={"theGameForm"} onSubmit={this.submit} noValidate>
            {/*Create a form which calls submit on finish, do not try to validate the dropdowns*/}

            <TextField
              id="Venue"
              label="Venue"
              placeholder="Venue"
              className={"VenueInput"}
              onChange={this.updateVenue}
            />
            {/*Venue text entry*/}

            <br />
            <br />
            {/*Spacing, so it's not one wide webpage, but has a column*/}

            <TextField
              id="datetime-local"
              type="datetime-local"
              className={"TimeInput"}
              defaultValue={this.state.time}
              onChange={this.updateTime}
            />
            {/*Time picker, which is technically a string, which is rather convenient*/}

            <br />
            <br />

            <InputLabel htmlFor="team-1">team1</InputLabel>
            <Select
              value={this.state.team1}
              onChange={this.updateTeam1}
              id='team1'
              className={'team1'}
              inputProps={{
                name: 'team1',
                id: 'team1',
              }}>
              {this.state.teams.map(team => (
                <MenuItem key={team.id} value={team.id} name={"team1-" + team.name.replace(/\s+/g, '-').toLowerCase()}>{team.name}</MenuItem>
              ))}
              {/*Start value is this.state.team1*/}
              {/*When changed call updateTeam1 with event*/}
              {/*For each team, make a menu item with a unique value and a name*/}
            </Select>
            {/*Select from dropdown of MenuItems onChange set team1 in state to the correct Team*/}

            <br />
            <br />

            <InputLabel htmlFor="team-2">team2</InputLabel>
            <Select
              value={this.state.team2}
              onChange={this.updateTeam2}
              id='team2'
              className={'team2'}
              inputProps={{
                name: 'team2',
                id: 'team2',
              }}
            >
              {this.state.teams.map(team => (
                <MenuItem key={team.id} value={team.id} name={"team2-" + team.name.replace(/\s+/g, '-').toLowerCase()}>{team.name}</MenuItem>
              ))}
              {/*For each team, make a menu item with a unique value and a name*/}
            </Select>
            {/*Select from dropdown of MenuItems onChange set team1 in state to the correct Team*/}

            <br />
            <br />

            <Button type={"submit"} variant={"raised"} color={"primary"} className={"submitForm"}>Submit</Button>
            {/*Submit form*/}
          </form>
        </div>
      )
    } else {
      // If not loaded, send progress wheel
      return (
        <CircularProgress />
      )
    }
  }
}

export default AddGame;
----

Well that was certainly longer than the rest, the Rest objects were short.

==== GameSummary.js
If the League is going to display Games, we need the summary, as games don't have a name or something, we require a lot more detail.

[source, jsx]
----
import ...

class GameSummary extends React.Component {
  render() {
    return (
      <li>
        <Link to={'/team/' + this.props.teams[0].id}>{this.props.teams[0].name}</Link> vs
        {/*Link to the first team in the game, with the team name*/}
        <Link to={'/team/' + this.props.teams[1].id}>{this.props.teams[1].name}</Link>
        {/*Link to the second team in the game, also with name*/}
        <p>{this.props.children} - {this.props.time}</p>
        {/*Linebreak, then the venue - time of the game*/}
      </li>
    )
  }
}

export default GameSummary; // Export this for easier imports
----

==== TestGames.js

Just adds games, as they don't do anything else, cut out the repeated setup and teardown from other tests

[source, js]
----

  'Test Adding Games' : function (browser) {
    let directory = "./reports/screenshots/TestGames/";
    browser
      .click('button[class~=addGame]')
      .pause(1000)
      // Click add a Game and wait for page to load
      .assert.containsText('h1', 'Nights Watch')
      // Check for title is correct
      .saveScreenshot(directory + "2-Add Game Screen.png")
      // Save a screenshot

      .setValue('input[id=Venue]', 'Sam Vimes Bowling Arena')
      .setValue('input[id=datetime-local]', "14-03-2020")
      // Set venue and datetime

      .click("div[class~=team1] div[role=button]")
      // Click the dropdown
      .waitForElementVisible('div[id=menu-team1] > div > ul > li[name=team1-team-1]', 1000)
      // Wait for dropdown to have dropped down
      .click("div[id=menu-team1] > div > ul > li[name=team1-team-1]")
      // Click team-1

      .pause(1000)
      // Wait for dropdown to close

      .click("div[class~=team2] div[role=button]")
      .waitForElementVisible('div[id=menu-team2] > div > ul > li[name=team2-team-3]', 1000)
      .click("li[name=team2-team-3]")
      // Make second team 3

      .saveScreenshot(directory + "filled in.png")
      // Save a screenshot

      .click(".theGameForm button[type=submit]")
      // Submit form

      .pause(1000)
      // Wait for page load

      .assert.containsText('.Games', "Sam Vimes Bowling Arena")
      .saveScreenshot(directory + "3-Added a game.png")
      // Check game added and displayed, as well as saving a screenshot

  }
};
----

include::test/5. Games Front and Back.adoc[]

==== Errors at this stage

===== Updating wrong value in state

With addGame and it's 4 update state functions, there was a problem with the team updaters.

[source, js]
----
updateTeam1(event) {
  this.setState({team1: event.target.value});
};

updateTeam2(event) {
  this.setState({team1: event.target.value});
};
----

Both were updating team 1, causing the lower dropdown to change the upper dropdown. This wasn't ideal.
So when spotted it was simply updated to team 1 and team 2 respectively, to fix this problem.

include::test/5. Games Front and Back.adoc[]

== Stage 2

=== Planning
Now that the main objects are all in with a simple front end implementation and backend controllers, that's the start done.

Next is features which are less reliant on everything being done so it will shift to a collection of user stories

==== Discussion with client
As fantastic as I thought it was being able to enter some data, and it remembered it.
The client seemed to think it may require some more of the features highlighted in the brief before it could be considered
usable for the task.

Together we discussed and created a list of user stories to implement next, in particular concerning scoring games,
a crucial part of the application.

The List was as Follows:

* Can add 3 players to play for team 1 in a game
* Can display these players to team 2
* Team 2, having seen Team 1's selection, can add 3 players
* Scores can be added and displayed for each of 3 sets of games for all players
* A player can add their handicap to a game
* Added score is adjusted for the handicap
* Points are awarded for a complete game
* Winning team displayed
* Highest Score possible 300
* Calculate player Handicaps
* Generate and display Player stats
* Generate and display Team stats
* League shows a table of all the teams stats

I also needed to rewrite the nightwatch testing to work with this and be less repetitive.
And after the page would need a good bit of polish to be usable.

==== How were Games going to be modelled?
Well to start with leagues should get games nicer, so a rota will be added between the objects for easier access.
Games also require players in the game, so a PlayerGame object can be used with scores to make this, methods will be added
to generate statistics like high handicap game and such.

.How games fit in
image::dev-pictures/match-objects.jpg[matchObjects, pdfwidth=100%]

Ignore how it's called matches, I nearly changed games to matches so one set could be a game, but it didn't contribute
to the functionality, so game stayed.

==  Back to Development
During this time springboot was updated from 1.5.9 to 2.0.0, so first everything had to be fixed

=== Making SpringBoot 2.0 work
Springboot 2.0 changed some of the repository commands. Which was confusing but easily fixed.

wherever there was a `findOne(id)`, there is now a

[source, java]
----
Optional<Object> optionalObject = repo.findById(id);
if(! optionalObject.isPresent()){
    return ResponseEntity.notFound().build();
}
Object object = optionalObject.get();
----

where Object is a Team or League or any other object.

This means that it now sends a `404` not a `500` if you try to find a non existent entity on get requests.
It also means that if a post request has invalid ids of other objects it returns a `400`.


=== Adding the Rota to make life easier
Just adds a link between League and Games, also if autogenerated game rota in future, makes it easier.



==== Rota.java

[source, java]
----
package com.saskcow.bowling.domain;

import ...

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity // Database storable
public class Rota {
    private @Id @GeneratedValue Long id;
    @OneToOne
    private League league; // One league, one rota
    @OneToMany(mappedBy = "rota", cascade = CascadeType.ALL)
    private List<Game> games; // One rota, many games
    private LocalDateTime start;
    private LocalDateTime end;
    private Integer weeklyGames;

    public Rota (League league) {
        this.league = league;
        this.games = new LinkedList<>();
    }

    // Makes one from the league

    public void addGame(Game game) {
        this.games.add(game);
    }

    public void deleteGame(Game game) {
        this.games.remove(game);
    }
}

----

Now it just needs the repository as well as links in league and game. And changing all the constructors. This process has been omitted as it's
been shown before.

=== Security
Also in springboot 2.0.0 security changed. This made it possible to include the OAuth planned in the original spec.

image::dev-pictures/security-flowchart.png[security]

The security should follow this for every incoming request. The login page will have a link to google to authenticate,
when authenticated, the user is able to use the site as desired.

This is achieved with up to date security

[source, groovy]
----
compile('org.springframework.security:spring-security-oauth2-client:5.0.3.RELEASE')
compile('org.springframework.security:spring-security-oauth2-jose:5.0.3.RELEASE')
compile('org.springframework.boot:spring-boot-starter-security')
testCompile('org.springframework.security:spring-security-test')
----
Added to dependencies in build.gradle, and a SecurityConfig.java

==== SecurityConfig.java

[source, java]
----
package com.saskcow.bowling.config;

import ...

@EnableWebSecurity
// Enable security in the application
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    // Extend the default WebSecurityConfigurerAdapter, so only what needs to be changed is changed
    // And the rest doesn't need to be written

    @Override // Replave WebSecurityConfigurerAdapter configure with this
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            // Disable CSRF, see errors for more details
            .exceptionHandling().authenticationEntryPoint(
                ((request, response, authException) -> response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Please Login!")))
            // If there is an authentication problem, throw a 401, unauthorized
                .and()
            .authorizeRequests()
                // Authorize requests which match
                .antMatchers("/login").permitAll()
                .antMatchers("/style").permitAll()
                .antMatchers("/built").permitAll()
                .antMatchers(HttpMethod.GET).permitAll()
                // Authorize all get requests, and all requests any method to /login or /style or /built
                .antMatchers(HttpMethod.POST).authenticated()
                .antMatchers(HttpMethod.DELETE).authenticated()
                // Require user to be authenticated to POST or DELETE
                .and()
            .oauth2Login();
            // Use an OAuth 2 login page
    }
}
----
Fairly simple, follows a pattern.

==== Login.ftl

[source]
----
<html>
<head lang="en">
    <meta charset="UTF-8"/>
    <title>Bowling Login</title>
    <link rel="stylesheet" href="/style/style.css"/>
    <link rel="stylesheet" href="/style/material.min.css"/>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>

<h1>Login to Bowling!</h1>

<a href="/oauth2/authorization/google">Login with google!</a>
<#-- Link to the made oauth google endpoint on click -->

</body>
</html>
----
Just a login page which links to

==== Getting OAuth Credentials

.Enter the oauth endpoint at get credentials
image::dev-pictures/google-credentials.png[googleCredentials]

Once completing this on google API console you get credentials, these should look these in application.properties.

image::dev-pictures/getting-credentials.png[gettingCredentials]

Save the redirect URL and it should all work

----
spring.security.oauth2.client.registration.google.client-id=548839700664-0shrfrqi5l617aqviipr482uhuvilmm5.apps.googleusercontent.com

spring.security.oauth2.client.registration.google.client-secret=iWUn6dklkA4ek9tHAE3zlfaw
----

These are not valid credentials, don't try it.

==== What it's like

When I try to make a post request it redirects me to `/login`

.Login to Bowling
image::dev-pictures/login-to-bowling.png[loginToBowling]

I click the URL and redirect to the google OAuth page

.Accounts Hidden
image::dev-pictures/login-with-google.png[loginWithGoogle]

Then any time I send a post request, like add a team, it lets me.

==== Errors with this
There were many, annoying, hard to fix errors which prevented correct authentication flow.

===== CSRF
Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application
in which they're currently authenticated.
CSRF attacks specifically target state-changing requests,
not theft of data, since the attacker has no way to see the response to the forged request.

According to the https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)[Owasp] page.
https://www.owasp.org/index.php/Top_10-2017_Top_10[Owasp also no longer includes it in the top 10 risks].

Therefore for a small bowling app, I disabled it with `.csrf().disable()` as it is very difficult to get it to operate with JSON payloads like it currently is.
Before disabling it would send a 403 on every post request, as none of them had the _csrf token.

*Please do not attempt csrf attacks now, thanks.*

===== Login Blocked
/login needs to be allowed for the user to access, otherwise the user cannot authenticate, and therefore cannot do anything.
This is a problem so `.antMatchers("/login").permitAll()` added to permit it.

===== No OAuth2
Originally when attempting OAuth I missed
[source, groovy]
----
compile('org.springframework.security:spring-security-oauth2-client:5.0.3.RELEASE')
compile('org.springframework.security:spring-security-oauth2-jose:5.0.3.RELEASE')
----
Which meant it had a username password login, not an OAuth login. This took me longer to realise than I'd like to admit.

=== Can add 3 players to play for team 1 in a game
First User story. This is a fairly core feature and many things rely on it so it's top of the list.
This means we'll need the PlayerGame and its associated controllers and repositories and a ui to add them into a game.

==== PlayerGame.java
This will be the object responsible for being a players appearance in a game

[source, java]
----
package com.saskcow.bowling.domain;

import ...

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
// All the usual constructors and getters and setters
public class PlayerGame {
    private @GeneratedValue @Id Long id;
    //  id as primary key
    @ManyToOne
    private Player player;
    // Player has many playerGames, playerGame has one player
    @ManyToOne
    private Team team;
    // Similar situation with teams as players
    @ManyToOne
    private Game game;
    // Also similar to players
    private Integer handicap;
    // Can overwrite player handicap

    public PlayerGame(Player player, Team team, Game game) {
        this.player = player;
        this.team = team;
        this.game = game;
    }
}

----

With parts in place for when scores added

==== Team.java, Player.java and Game.java
All need to be able to do calculations based on playerGames eventually, so will all need a link.
Thus all 3 got the following added.

[source, java]
----
private List<PlayerGame> playerGames;
// Added to all 3 classes

this.playerGames = new LinkedList<>();
// Added to the constructors

public void addPlayerGame(PlayerGame playerGame) {
    this.playerGames.add(playerGame);
}

public void deletePlayerGame(PlayerGame playerGame) {
    this.playerGames.remove(playerGame);
}

// Both functions added to make it easy to manipulate the playerGame list.

public void addAllPlayerGame(List<PlayerGame> playerGames) {
    this.playerGames.addAll(playerGames);
}

// Only teams and games got this to make it easier in the controller
----

==== PlayerGameControllerTest.java
Individually, there should be no reason to see one playerGame, so no get request should be required. However they do have
to be added and removed.
Also since 3 on a team, in an order, it makes sense to add 3 in one request.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@RunWith(MockitoJUnitRunner.class)
public class PlayerGameControllerTest {

    @Mock
    private PlayerGameRepository repo;
    @Mock
    private PlayerRepository playerRepository;
    @Mock
    private TeamRepository teamRepository;
    @Mock
    private GameRepository gameRepository;
    // Mock required repositories
    private MockMvc mockMvc;
    // Has MockMvc for requests

    @Before
    public void setUp() {
        mockMvc = MockMvcBuilders.standaloneSetup(new PlayerGameController(repo, playerRepository, teamRepository, gameRepository))
                .build();
    } // Create a PlayerGameController as a mockMvc

    @Test
    public void addPlayerGame_shouldSavePlayerGame() throws Exception {
        League cityWatch = new League(1L, "City Watch", null, new LinkedList<>());
        cityWatch.setRota(new Rota(cityWatch));
        // Create league and rota

        Team cableStreet = new Team(1L, "Cable Street Particulars", null, new LinkedList<>(), cityWatch, new LinkedList<>());
        Team nightWatch = new Team(2L, "The Night Watch", null, new LinkedList<>(), cityWatch, new LinkedList<>());

        cableStreet.setPlayers(new LinkedList<>(Arrays.asList(
                new Player(1L, "Findthee Swing", cableStreet, new LinkedList<>()),
                new Player(2L, "Carcer", cableStreet, new LinkedList<>()),
                new Player(3L, "Gerald Leastways, a.k.a. Ferret", cableStreet, new LinkedList<>()),
                new Player(4L, "Henry 'The Hamster' Higgins", cableStreet, new LinkedList<>())
        )));
        nightWatch.setPlayers(new LinkedList<>(Arrays.asList(
                new Player(5L, "Sam Vimes", nightWatch, new LinkedList<>()),
                new Player(6L, "Carrot Ironfoundersson", nightWatch, new LinkedList<>()),
                new Player(7L, "Nobby Nobbs", nightWatch, new LinkedList<>()),
                new Player(8L, "Fred Colon", nightWatch, new LinkedList<>())
        )));

        // Create teams and add players

        Game game = new Game(
            1L,
            cityWatch.getRota(),
            LocalDateTime.now(Clock.systemUTC()),
            "The Shades", Arrays.asList(cableStreet,
            nightWatch),
            new LinkedList<>()
        );
        cableStreet.addGame(game); nightWatch.addGame(game);

        // Create a game and add teams to it

        PlayerGame swingGame = new PlayerGame(1L, cableStreet.getPlayers().get(0), cableStreet, game, new LinkedList<>(), null);
        PlayerGame carcerGame = new PlayerGame(2L, cableStreet.getPlayers().get(1), cableStreet, game, new LinkedList<>(), null);
        PlayerGame geraldGame = new PlayerGame(3L, cableStreet.getPlayers().get(2), cableStreet, game, new LinkedList<>(), null);

        /// Create 3 playergames

        when(repo.save(new PlayerGame(cableStreet.getPlayers().get(0), cableStreet, game))).thenReturn(swingGame);
        when(repo.save(new PlayerGame(cableStreet.getPlayers().get(1), cableStreet, game))).thenReturn(carcerGame);
        when(repo.save(new PlayerGame(cableStreet.getPlayers().get(2), cableStreet, game))).thenReturn(geraldGame);
        // When saving playerGame, return the playerGame

        when(gameRepository.findById(game.getId())).thenReturn(Optional.of(game));

        when(playerRepository.findById(1L)).thenReturn(Optional.of(swingGame.getPlayer()));
        when(playerRepository.findById(2L)).thenReturn(Optional.of(carcerGame.getPlayer()));
        when(playerRepository.findById(3L)).thenReturn(Optional.of(geraldGame.getPlayer()));

        when(teamRepository.findById(cableStreet.getId())).thenReturn(Optional.of(cableStreet));
        // When finding a game, player or team, return an Optional<T> containing it

        mockMvc.perform(post("/api/playergame")
                // Send a post to /api/playergame
                .content("{\"playerIds\": [1, 2, 3], \"teamId\": \"1\", \"gameId\": \"1\"}")
                // Include these 3 playerIds, the teamId, and the gameId
                .contentType("application/json"))
                .andExpect(status().isCreated())
                // Expect 201
                .andExpect(header().string("Location", "http://localhost:8080/api/playergame/" + swingGame.getId()));
                // Expect location exists

        assertThat(game.getPlayerGames().get(0)).isEqualTo(swingGame);
        assertThat(game.getPlayerGames().get(1)).isEqualTo(carcerGame);
        assertThat(game.getPlayerGames().get(2)).isEqualTo(geraldGame);
        assertThat(game.getPlayerGames().size()).isEqualTo(3);
        // Assert that the game has all 3 playerGames and no others
        verify(repo, times(1)).save(new PlayerGame(cableStreet.getPlayers().get(0), cableStreet, game));
        verify(repo, times(1)).save(new PlayerGame(cableStreet.getPlayers().get(1), cableStreet, game));
        verify(repo, times(1)).save(new PlayerGame(cableStreet.getPlayers().get(2), cableStreet, game));
        // Check each playerGame was saved once
        verify(playerRepository, times(3)).save(isA(Player.class));
        // Check all 3 players saved
        verify(gameRepository, times(1)).save(isA(Game.class));
        // Check Game saved
        verify(teamRepository, times(1)).save(isA(Team.class));
        // Check Team saved
    }

    @Test
    public void deletePlayerGame_shouldDeletePlayerGame() throws Exception {
        Team cableStreet = new Team(1L, "Cable Street Particulars", null, new LinkedList<>(), null, new LinkedList<>());
        Team nightWatch = new Team(2L, "The Night Watch", null, new LinkedList<>(), null, new LinkedList<>());

        cableStreet.setPlayers(new LinkedList<>(Arrays.asList(
                new Player(1L, "Findthee Swing", cableStreet, new LinkedList<>()),
                new Player(2L, "Carcer", cableStreet, new LinkedList<>()),
                new Player(3L, "Gerald Leastways, a.k.a. Ferret", cableStreet, new LinkedList<>()),
                new Player(4L, "Henry 'The Hamster' Higgins", cableStreet, new LinkedList<>())
        )));

        Game game = new Game(1L, null, LocalDateTime.now(Clock.systemUTC()), "The Shades", Arrays.asList(cableStreet, nightWatch), new LinkedList<>());
        cableStreet.addGame(game); nightWatch.addGame(game);

        PlayerGame swingGame = new PlayerGame(1L, cableStreet.getPlayers().get(0), cableStreet, game, new LinkedList<>(), null);
        PlayerGame carcerGame = new PlayerGame(2L, cableStreet.getPlayers().get(1), cableStreet, game, new LinkedList<>(), null);
        PlayerGame geraldGame = new PlayerGame(3L, cableStreet.getPlayers().get(2), cableStreet, game, new LinkedList<>(), null);

        // Same objects created as in post test

        cableStreet.getPlayers().get(0).addPlayerGame(swingGame);
        cableStreet.getPlayers().get(1).addPlayerGame(carcerGame);
        cableStreet.getPlayers().get(2).addPlayerGame(geraldGame);
        cableStreet.addPlayerGame(swingGame);
        cableStreet.addPlayerGame(carcerGame);
        cableStreet.addPlayerGame(geraldGame);
        game.addPlayerGame(swingGame);
        game.addPlayerGame(carcerGame);
        game.addPlayerGame(geraldGame);

        // Add the PlayerGames to everything

        doNothing().when(repo).deleteById(isA(Long.class));
        // When delete attempted, do nothing

        when(repo.findById(swingGame.getId())).thenReturn(Optional.of(swingGame));
        // Return Optional<Game> swingGame when find attempted

        mockMvc.perform(delete("/api/playergame/1"))
                // Send delete to /api/playergame/1
                .andExpect(status().isNoContent());
                // Expect 204

        verify(repo, times(1)).deleteById(1L);
        // Check it was deleted
        assertThat(cableStreet.getPlayerGames()).doesNotContain(swingGame);
        assertThat(cableStreet.getPlayerGames()).contains(carcerGame);
        assertThat(cableStreet.getPlayerGames()).contains(geraldGame);
        // Check only swingGame deleted
    }

}
----

==== PlayerGameController.java
Tests have to pass pass.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@Controller
public class PlayerGameController {

    private PlayerGameRepository repo;
    private PlayerRepository playerRepository;
    private TeamRepository teamRepository;
    private GameRepository gameRepository;
    // Get all the necessary repositories

    @Autowired
    public PlayerGameController(PlayerGameRepository repo, PlayerRepository playerRepository, TeamRepository teamRepository, GameRepository gameRepository){
        this.repo = repo;
        this.playerRepository = playerRepository;
        this.teamRepository = teamRepository;
        this.gameRepository = gameRepository;
    }
    // When loading application load repos from application context

    @PostMapping("/api/playergame")
    // On post requests to /api/playergame, slightly different to usual since the rewrite, this looks cleaner
    public ResponseEntity<?> savePlayerGame(@RequestBody PlayerGameRest playerGameRest) {
        // Return a ResponseEntity and take request JSON as a PlayerGameRest
        Optional<Player> optionalPlayer0 = playerRepository.findById(playerGameRest.getPlayerIds().get(0));
        Optional<Player> optionalPlayer1 = playerRepository.findById(playerGameRest.getPlayerIds().get(1));
        Optional<Player> optionalPlayer2 = playerRepository.findById(playerGameRest.getPlayerIds().get(2));
        Optional<Team> optionalTeam = teamRepository.findById(playerGameRest.getTeamId());
        Optional<Game> optionalGame = gameRepository.findById(playerGameRest.getGameId());
        // Get the 3 players, the team the players are on, and the game they are playing in.

        if (! optionalGame.isPresent() || ! optionalPlayer0.isPresent() || ! optionalPlayer1.isPresent() || ! optionalPlayer2.isPresent() || ! optionalTeam.isPresent()){
            return ResponseEntity.badRequest().build();
        }
        // Check all objects are not null, if they are, that's a 400 sent straight back

        Player player0 = optionalPlayer0.get();
        Player player1 = optionalPlayer1.get();
        Player player2 = optionalPlayer2.get();
        Team team = optionalTeam.get();
        Game game = optionalGame.get();
        // Get objects from the optionals

        if(game.getPlayerGames().size() > 3) {
            return ResponseEntity.badRequest().build();
        }
        // If the game already has enough players, they can't add more, so send back a 400

        PlayerGame playerGame0 = repo.save(new PlayerGame(player0, team, game));
        PlayerGame playerGame1 = repo.save(new PlayerGame(player1, team, game));
        PlayerGame playerGame2 = repo.save(new PlayerGame(player2, team, game));
        // Create the 3 playergames and save them

        player0.addPlayerGame(playerGame0);
        player1.addPlayerGame(playerGame1);
        player2.addPlayerGame(playerGame2);
        team.addAllPlayerGame(Arrays.asList(playerGame0, playerGame1, playerGame2));
        game.addAllPlayerGame(Arrays.asList(playerGame0, playerGame1, playerGame2));
        // Add playerGames to the players, teams and games

        playerRepository.save(player0);
        playerRepository.save(player1);
        playerRepository.save(player2);
        teamRepository.save(team);
        gameRepository.save(game);
        // Save changes to other objects

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest().path("/{id}")
                .buildAndExpand(game.getId()).toUri();
        // Get URI for deleting only

        return ResponseEntity.created(location).build();
        // Return a 201 with the location
    }

    @DeleteMapping("/api/playergame/{id}")
    // All delete requests to api/playergame/{id}
    public ResponseEntity<Void> deletePlayerGame(@PathVariable Long id) {
        // Take id from path
        Optional<PlayerGame> optionalPlayerGame = repo.findById(id);
        if (! optionalPlayerGame.isPresent()){
            return ResponseEntity.notFound().build();
        }
        PlayerGame playerGame = optionalPlayerGame.get();
        // Get player Game returning 404 if null

        playerGame.getPlayer().deletePlayerGame(playerGame);
        playerGame.getTeam().deletePlayerGame(playerGame);
        playerGame.getGame().deletePlayerGame(playerGame);
        // Remove playerGame from team, game and player

        playerRepository.save(playerGame.getPlayer());
        teamRepository.save(playerGame.getTeam());
        gameRepository.save(playerGame.getGame());
        // Save changes to player, team and game

        repo.deleteById(id);
        // Delete playerGame
        return ResponseEntity.noContent().build();
        // Return 204
    }
}

----

==== Errors at This stage
For once, nothing which hadn't been seen before.

=== Front End for Team 1 PlayerGames

==== App.js
We always start here for front ends, and now is no different, I need a route for adding these PlayerGames.
Just add this.
`<Route path="/game/:id/add-players" component={AddPlayers}/>`
And that's the necessary changes.

==== AddPlayers.js
Rather crucially in adding playerGames, we require playerGames to have an add ui, since it adds players plural,
it is called AddPlayers.js.

[source, jsx]
----
import ...

class AddPlayers extends React.Component{
  constructor(props) {
    super();
    this.state = ({id: props.id, status: 0, teams: [], player1: 0, player2: 0, player3: 0});
    // Set default state, status 0 as 0 teams back
    this.handleUserInput = this.handleUserInput.bind(this);
    this.isValid = this.isValid.bind(this);
    this.getData = this.getData.bind(this);
    this.submit = this.submit.bind(this);
    // Everything gets to use this, so we bind this to everything
    this.getData(props.match.params.id);
  }

  handleUserInput (e) {
    this.setState({[e.target.name]: e.target.value});
    // On User input, set {name: value} in state, useful so there isn't 50 (3) input handlers
  }

  isValid() {
    return (![this.state.player1, this.state.player2, this.state.player3].includes(0) &&
      [this.state.player1, this.state.player2, this.state.player3].length === new Set([this.state.player1, this.state.player2, this.state.player3]).size);
    // Check that all of them are not 0, which is the value of No Player
    // Check that there are no duplicates, a Set has same length as a list as a Set removes duplicates
  }

  submit(event) {
    event.preventDefault();
    // Prevent the default submit behaviour
    if(this.isValid()){
      // If no unset or duplicates
      axios.post("/api/playergame", {
        teamId: this.state.teams[0].id,
        // Send id of team 1
        gameId: this.state.id,
        // Send the Game id
        playerIds: [this.state.player1, this.state.player2, this.state.player3]
        // Send id in order of the 3 players
      })
        .then(response => {
          window.location.href = '/game/' + this.state.id;
          console.log("created at " + response.headers.location);
          // Redirect to game
        })
        .catch(function (error) {
          if(error.response.status === 401){
            window.location.href = '/login';
          } else {
            console.log(error);
          }
          // If not authenticated go to login, otherwise log error
        });
    } else {
      console.log("Invalid input.");
      this.setState({err: "Invalid input, check for unset or duplicates."})
      // Set error if not valid
    }
  }

  getData(id) {
    axios.get('/api/game/' + id)
      // Send get request to /api/game/{id}
      .then(response => {
        let teamsPlus = response.data.teams.map(team => team.id);
        // get teams from game and create a list with the team ids in order
        response.data.teams.forEach(team => {
          // For each team in the game
          axios.get('/api/team/' + team.id)
            // Send a get request for the team
            .then( tResponse => {
              teamsPlus[teamsPlus.indexOf(team.id)] = tResponse.data;
              this.setState({teams: teamsPlus, status: this.state.status + 1})
              // Replace teams id in list with the team data
              // Increment status so when 2 it has loaded
            })
            .catch(error => {
              console.log(error)
              // Log errors
            })
        });
      })
      .catch(error => {
        console.log(eror)
        // Log errors
      })
  }

  render() {
    if(this.state.status === 2){
      // When fully loaded
      return (
        <div className={"AddScreen"}>
          {/*Contain in div with class AddScreen*/}
          <form className={"thePlayersForm"} onSubmit={this.submit} noValidate>
            {/*Create a form which calls submit when submited*/}

            <InputLabel htmlFor="player-1">player1</InputLabel>
            <Select
              value={this.state.player1}
              onChange={this.handleUserInput}
              id='player1'
              className={'player1'}
              inputProps={{
                name: 'player1',
                id: 'player1',
              }}>
              <MenuItem value={0}><em>None</em></MenuItem>
              {this.state.teams[0].players.map(player => (
                <MenuItem key={player.id} value={player.id} name={"player1-" + player.name.replace(/\s+/g, '-').toLowerCase()}>{player.name}</MenuItem>
              ))}
            </Select>
            {/*Create a dropdown select, with team 1s players available as dropdowns*/}
            {/*onChange call handleUserInput, has name of player1, so this.state.player1 set to player id*/}

            <br />
            <br />

            <InputLabel htmlFor="player-2">player2</InputLabel>
            <Select
              value={this.state.player2}
              onChange={this.handleUserInput}
              id='player2'
              className={'player2'}
              inputProps={{
                name: 'player2',
                id: 'player2',
              }}>
              <MenuItem value={0}><em>None</em></MenuItem>
              {this.state.teams[0].players.map(player => (
                <MenuItem key={player.id} value={player.id} name={"player2-" + player.name.replace(/\s+/g, '-').toLowerCase()}>{player.name}</MenuItem>
              ))}
            </Select>
            {/*Another select but for player2*/}

            <br />
            <br />

            <InputLabel htmlFor="player-3">player3</InputLabel>
            <Select
              value={this.state.player3}
              onChange={this.handleUserInput}
              id='player3'
              className={'player3'}
              inputProps={{
                name: 'player3',
                id: 'player3',
              }}>
              <MenuItem value={0}><em>None</em></MenuItem>
              {this.state.teams[0].players.map(player => (
                <MenuItem key={player.id} value={player.id} name={"player3-" + player.name.replace(/\s+/g, '-').toLowerCase()}>{player.name}</MenuItem>
              ))}
            </Select>
            {/*Another select but for player3*/}

            <br/>
            <br/>

            <Button type={"submit"} variant={"raised"} color={"primary"} className={"submitForm"}>Submit</Button>
            {/*Submit form*/}

          </form>
          <p className={"errorMessage"}>{this.state.err}</p>
          {/*If there is an error, show it*/}
        </div>
      )
    } else{return <CircularProgress />}
      // If loading, show loading wheel
  }
}

export default AddPlayers; // Export for easier imports
----

==== Errors at this stage

===== Wrong order back
When the requests are sent, they don't wait before sending another, they act asynchronously.
This means that both requests are sent, and then it goes off to do other things before the response comes back.
This would mean that sometimes the second request comes back in the wrong order. This causes the player dropdowns, to contain
players of the other team. This would cause issues as it happened sometimes, so took a lot of reloading data to debug.

Eventually

[source, js]
----
let teamsPlus = this.state.teams.slice();
teamsPlus.push(tResponse.data);
this.setState({teams: teamsPlus, status: this.state.status + 1})

//replaced by

teamsPlus[teamsPlus.indexOf(team.id)] = tResponse.data;
this.setState({teams: teamsPlus, status: this.state.status + 1})
// With the following out of the recursion
let teamsPlus = response.data.teams.map(team => team.id);
----

This preserved the order the game set so teams were displayed correctly.

==== isNotValid
I got all confused and put an `!` in front of the isValid logic. This caused the opposite of what I wanted to happen.
Since the function has worked wonderfully since the removal of this.

=== Can display these players to team 2
Fairly crucial part of this, is showing what the selection was.
I tried to replicate
image::other-pictures/TeamVTeam.png
so I have a placeholder for all the data to be added later.

==== GameView.java
Currently nothing sends PlayerGames from the back end, this is important.

[source, java]
----
private List<PlayerGameView> playerGames;
// GameViews have these now

this.playerGames = game.getPlayerGames().stream().map(PlayerGameView::new).collect(Collectors.toList());
// Get all the playerGames and make them playerGameViews instead
----

==== PlayerGameView.java
Necessary detail for a playerGame

[source, java]
----
package com.saskcow.bowling.view;

import ...

@Data
@NoArgsConstructor
public class PlayerGameView {
    private Long id;
    private PlayerViewSummary player;
    private TeamViewSummary team;
    // private List<ScoreViewSummary> scores;
    private Integer handicap;
    // id, player team and handicap are all important for a playerGame

    public PlayerGameView (PlayerGame playerGame) {
        this.id = playerGame.getId();
        this.player = playerGame.getPlayer() != null ? new PlayerViewSummary(playerGame.getPlayer()) : null;
        this.team = new TeamViewSummary(playerGame.getTeam());
        // set values from playerGame making view objects where necessary
        // this.scores = playerGame.getScores().stream().map(ScoreViewSummary::new).collect(Collectors.toList());

        if (playerGame.getPlayer() != null){
            this.handicap = playerGame.getHandicap() == null ? playerGame.getPlayer().getHandicap() : playerGame.getHandicap();
        } // Get the handicap from the player if the playerGame doesn't have one
    }
}
----

==== App.js
Once again, we need a route `<Route exact path="/game/:id/" component={Game}/>` will do it.

==== Game.js
Now we need to write `Game.js` to show on the path. By making tables, lots of table generating.

[source, jsx]
----
import ...

class Game extends React.Component {

  constructor(props) {
    super();
    // Make this usable
    this.state = {status: "Loading"};
    // Set default state as Loading
    this.getGame = this.getGame.bind(this);
    this.getGame(props.match.params.id);
    // Allow getGame to setState and call it with the id
  }

  getGame(id) {
    axios.get('/api/game/' + id)
    // Get the game
      .then(response => {
        this.setState({
          status: "OK",
          id: id,
          game: response.data
          // Map response to state
        })
      })
      .catch(error => {
        console.log(error);
        // Simple error logging
      });
  }

  table() {
    let tables = [];
    // Start with empty
    if (this.state.game.playerGames.length) {
      // If it isn't completely empty
      for(let i = 0; i< Math.floor(this.state.game.playerGames.length / 3); i++){
        // for i in range playerGames/3
        // Once if one team added, twice if both added
        tables.push(
          // Add this table to the list
          <table key={i}>
            {/*Set key of table for iteration*/}
            <thead>
            <tr>
              <th colSpan={10}>{this.state.game.teams[i].name}</th>
              <th>Score</th>
              {/*Team name and Score at top*/}
            </tr>
            <tr>
              <th width="10%">HCP</th>
              <th width="40%">Bowler</th>
              <th width="10%" colSpan={2}>Game 1</th>
              <th width="10%" colSpan={2}>Game 2</th>
              <th width="10%" colSpan={2}>Game 3</th>
              <th width="10%" colSpan={2}>Total</th>
              <th width="10%">Pts</th>
              {/*Second set of headings with set width, games 2 wide for scratch and hanicap*/}
            </tr>
            </thead>
            {this.state.game.playerGames.slice(3 * i, 3 * i + 3).map(playerGame => (
              <tbody key={playerGame.id}>
              <tr>
                <td rowSpan={2}>Handicap</td>
                <td rowSpan={2}>{playerGame.player.name}</td>
                <td>{playerGame.scores[0] ? playerGame.scores[0].scratch : ""}</td>
                <td>{playerGame.scores[0] ? playerGame.scores[0].handicapped : ""}</td>
                <td>{playerGame.scores[1] ? playerGame.scores[1].scratch : ""}</td>
                <td>{playerGame.scores[1] ? playerGame.scores[1].handicapped : ""}</td>
                <td>{playerGame.scores[2] ? playerGame.scores[2].scratch : ""}</td>
                <td>{playerGame.scores[2] ? playerGame.scores[2].handicapped : ""}</td>
                <td>total scratch</td>
                <td>total handicapped</td>
                <td rowSpan={2}>Points</td>
                {/*Put in all scratch and handicaps, if null, make it blank*/}
              </tr>
              <tr>
                <td colSpan={2}>{playerGame.scores[0] ? playerGame.scores[0].score : ""}</td>
                <td colSpan={2}>{playerGame.scores[1] ? playerGame.scores[1].score : ""}</td>
                <td colSpan={2}>{playerGame.scores[2] ? playerGame.scores[2].score : ""}</td>
                <td colSpan={2}>total points</td>
                {/*Put in all scores, if null, make it blank*/}
              </tr>
              </tbody>
            ))}
          </table>)}
    }
    return tables
  //  return the list of tables
  }

  render() {
    if(this.state.status === "OK") {
      return (
        <div className="App">
          <header className="App-header">
            <h1 className="App-title"> <Link to={"/team/" + this.state.game.teams[0].id}>{this.state.game.teams[0].name}</Link> vs <Link to={"/team/" + this.state.game.teams[1].id}>{this.state.game.teams[1].name}</Link></h1>
            <h3>{new Date(Date.parse(this.state.game.time)).toLocaleString('en-GB', { timeZone: 'UTC' })} at {this.state.game.venue}</h3>
            {/*Header of file, states team vs team, location and time*/}
          </header>
          {this.table()}
          {/*Add the table*/}
        </div>
      )
    } else {
      return <CircularProgress color={"primary"} />
    //  If not loaded give a loading wheel
    }
  }
}

export default Game;
----

Looks good with the players added!

image::dev-pictures/game-page-1.png[gamePage, pdfwidth=100%]

==== Errors at this stage

===== Undefined
`Uncaught TypeError: Cannot read property 'whatever the property was' of undefined`

Since players don't have scores, they cannot read the scratch score of one. Which is a bit of an oversight.
To protect against this `playerGame.scores[2] ? playerGame.scores[2].handicapped : ""` is used. This contains a ternary
operator which effectively sends the value if it isn't undefined, if it is, send blank.

===== Requires key
`Each child in an array should have a unique "key" prop.
Check the render method of Component.`

Each component in an array should have a key. React can then display everything in this array. This includes the maps.
Therefore everywhere it is done `key={uniqueKey}` should be added.

=== Team 2 Can add Players Too
With the url parameters, it is hard to addPlayers and say which team without asking the user.
Therefore AddPlayers will be in a dropdown on the Game page so it can take props directly!

==== App.js
For once something is getting removed from App.js. This is a first, add-game will no longer be required.
`<Route path="/game/:id/add-players" component={AddPlayers}/>` Removed!

==== AddPlayers.js
This will now need to work off of props and 2 teams, it shouldn't be too drastic a change.

[source, jsx]
----
this.getData(props.game.teams);
// Game passes in Game, so just take team data, as that's all it needs right now.

getData(teams) {
    let teamsPlus = teams.map(team => team.id);
    teams.forEach(team => {
      axios.get('/api/team/' + team.id)
        .then( tResponse => {
          teamsPlus[teamsPlus.indexOf(team.id)] = tResponse.data;
          this.setState({teams: teamsPlus, status: this.state.status + 1})
        })
        .catch(error => {
          console.log(error)
        })
    });
  }
// getData replaced with this, instead of getting teams first, it takes it from game directly.

// Well now it works from props, that was easy, now for 2 teams

// Taking the prop team, which is 0 or 1 based on team index
- [0]
+ [this.props.team]
// This means it gets the right team, and it all works for whatever team is given
----

==== Game.js
This will have to contain addPlayers, a dropdown should be nice.

[source, jsx]
----
addPlayers(team) {
  return (
    <ExpansionPanel key={team} className={'add-to-' + this.state.game.teams[team].name.replace(/\s+/g, '-').toLowerCase()}>
      {/*Create an expansion panel which drops down to show content*/}
      <ExpansionPanelSummary expandIcon={<KeyboardArrowDown />}>
        {/*Summary has an arrowDown icon*/}
        <Typography className={"add_players"}>Add players to {this.state.game.teams[team].name}</Typography>
        {/*Has Add players to {TeamName} as a title*/}
      </ExpansionPanelSummary>
      <ExpansionPanelDetails>
        <AddPlayers id={this.state.game.id} team={team} game={this.state.game} />
        {/*Drops down to show AddPlayers with the props specified earlier*/}
      </ExpansionPanelDetails>
    </ExpansionPanel>
  )
}

// and to tables()

if (! this.state.game.playerGames.length) {
  tables.push(this.addPlayers(0))
  // If no players, add players to team 1
} else if (this.state.game.playerGames.length < 6){
  tables.push(this.addPlayers(1))
  // If not full, but not empty, put players in team 2
}

// added at end of function
----

Now there are nice dropdowns to add players, and it'll work for both teams.

.Add players in dropdown
image::dev-pictures/game-collapsed.png[gameCollapsed, pdfwidth=100%]
image::dev-pictures/game-dropdowns.png[gameExtended, pdfwidth=100%]

And it already displays it for both, how convenient.

=== Scores Can be Added and Displayed
This is another big part, lots of back and front end work again

==== Score.java
Something to hold scratch handicap and score for one part of a game.

[source, java]
----
package com.saskcow.bowling.domain;

import ...

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = "playerGame")
public class Score {
    private @GeneratedValue @Id Long id;
    @ManyToOne
    private PlayerGame playerGame;
    // PlayerGame has many, only link, nice and easy
    private Integer scratch;
    private Integer handicapped;
    private Integer score;
    private boolean total;
    // Has scratch, handicap, score and total, which isn't used just yet

    public Score(PlayerGame playerGame, Integer scratch){
        this.playerGame = playerGame;
        this.scratch = scratch;
        this.handicapped = scratch;
    }

    public Score(PlayerGame playerGame, Integer scratch, Integer handicap){
        this.playerGame = playerGame;
        this.scratch = scratch;
        this.handicapped = scratch + handicap;
    }

    public Score(PlayerGame playerGame, Integer scratch, Integer handicap, boolean total){
        this.playerGame = playerGame;
        this.scratch = scratch;
        this.total = total;
        this.handicapped = scratch + handicap;
    }

    public Score(Long id, PlayerGame playerGame, Integer scratch, Integer handicapped, Integer score){
        this.id = id;
        this.playerGame = playerGame;
        this.scratch = scratch;
        this.handicapped = handicapped;
        this.score = score;
    }

    // Many constructors depending on scenario, total only set if true, else it's false as it's a primitive
    // constructors just map args other than handicapped often made with handicap

}
----

==== PlayerGame.java
Requires some updates, now scores exist, playergames need scores
[source, java]
----
@OneToMany(mappedBy = "playerGame", cascade = CascadeType.ALL)
private List<Score> scores;
// 3 rounds in a game, so many scores needed


public PlayerGame(Player player, Team team, Game game) {
    this.player = player;
    this.team = team;
    this.game = game;
    this.scores = new LinkedList<>();
    // Now creates an empty list of scores
}


// Added for manipulating scores

public void addScore(Score score) {
    this.scores.add(score);
} // Append scores list with a score

public void deleteScore(Score score) {
    this.scores.remove(score);
} // Remove given object from score list

public Integer getPoints() {
    return this.scores.stream().reduce(0, (a, b) -> a + b.getScore(), (a, b) -> a + b);
} // For each score, get the points and add all the points into an Integer
----

==== PlayerGameView.java
Also now should show the scores

[source, java]
----
private List<ScoreViewSummary> scores;

this.scores = playerGame.getScores().stream().map(ScoreViewSummary::new).collect(Collectors.toList());
----

Simple, just add scores as summarys.

==== ScoreViewSummary.java
Get id, scratch, handicapped ,and score, all that it needs.

[source, java]
----
@Data
@NoArgsConstructor
public class ScoreViewSummary {
    private Long id;
    private Integer scratch;
    private Integer handicapped;
    private Integer score;

    public ScoreViewSummary(Score score) {
        this.id = score.getId();
        this.scratch = score.getScratch();
        this.handicapped = score.getHandicapped();
        this.score = score.getScore();
    }
}
----

==== ScoreControllerTest.java
Last one in the project now. It's also short.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@RunWith(MockitoJUnitRunner.class)
// Allow
public class ScoreControllerTest {

    @Mock
    private ScoreRepository repo;
    @Mock
    private PlayerGameRepository playerGameRepository;
    private MockMvc mockMvc;

    @Before
    public void setUp() {
        mockMvc = MockMvcBuilders.standaloneSetup(new ScoreController(repo, playerGameRepository))
                .build();
    }
    // Setup mockMvc with mocked repositories

    @Test // Run with the rest of the tests
    public void addScore_shouldSaveTheScore() throws Exception {
        PlayerGame playerGame = new PlayerGame(1L, null, null, null, new LinkedList<>(), 10);
        Score score1 = new Score(1L, playerGame, 101, 104, null);
        Score score2 = new Score(2L, playerGame, 102, 105, null);
        Score score3 = new Score(3L, playerGame, 103, 106, null);
        playerGame.addScore(score1);
        playerGame.addScore(score2);
        // Create objects, just a playerGame and 3 scores, add 2 of the scores to the player

        when(repo.save(isA(Score.class))).thenReturn(score3);
        // When saving a Score, return score3
        when(playerGameRepository.save(isA(PlayerGame.class))).thenReturn(playerGame);
        // When saving a PlayerGame, return playerGame
        when(playerGameRepository.findById(1L)).thenReturn(Optional.of(playerGame));
        // When finding playerGame, return Optional<PlayerGame> playerGame

        mockMvc.perform(post("/api/score")
                // Send the post request to /api/score
                .content("{\"playerGameId\": \"1\", \"scratch\": \"103\", \"handicap\": \"3\"}")
                // Send this content
                .contentType("application/json"))
                .andExpect(status().isCreated())
                // Expect 201
                .andExpect(header().string("Location", "http://localhost:8080/api/score/" + score3.getId()));
                // Get delete location

        assertThat(playerGame.getScores()).contains(score3);
        verify(repo, times(1)).save(isA(Score.class));
        // Check score saved and in playerGame
    }

    @Test
    public void deleteScore_shouldDeleteScore() throws Exception {
        PlayerGame playerGame = new PlayerGame(1L, null, null, null, new LinkedList<>(), 10);
        Score score1 = new Score(1L, playerGame, 101, 104, null);
        Score score2 = new Score(2L, playerGame, 102, 105, null);
        Score score3 = new Score(3L, playerGame, 103, 106, null);
        playerGame.addScore(score1);
        playerGame.addScore(score2);
        playerGame.addScore(score3);
        // Create a PlayerGame with 3 Scores

        doNothing().when(repo).deleteById(isA(Long.class));
        // When deleting a score, do nothing
        when(repo.findById(score3.getId())).thenReturn(Optional.of(score3));
        // When finding score3, return Optional score3

        mockMvc.perform(delete("/api/score/3"))
                // Send delete to /api/score/{score3 id}
                .andExpect(status().isNoContent());
                // Expect 204

        verify(repo, times(1)).deleteById(3L);
        // Expect score3 deleted
        assertThat(playerGame.getScores()).doesNotContain(score3);
        assertThat(playerGame.getScores()).contains(score1);
        // Check score3 not in playerGame scores, but other is
    }
}
----

==== ScoreController.java
Makes tests pass, routes the requests.

[source, java]
----
package com.saskcow.bowling.controller;

import ...

@Controller
public class ScoreController {

    private ScoreRepository repo;
    private PlayerGameRepository playerGameRepository;

    @Autowired
    public ScoreController(ScoreRepository repo, PlayerGameRepository playerGameRepository) {
        this.repo = repo;
        this.playerGameRepository = playerGameRepository;
    }
    // On application start, send Repositories here from application context and make a ScoreController

    @RequestMapping(value = "/api/score", method = RequestMethod.POST)
    // Send post requests to /api/score here
    public ResponseEntity<?> saveScore(@RequestBody ScoreRest score) {
        // Returns a ResponseEntity and takes JSON made into a ScoreRest

        Optional<PlayerGame> optionalPlayerGame = playerGameRepository.findById(score.getPlayerGameId());
        if (! optionalPlayerGame.isPresent()){
            return ResponseEntity.badRequest().build();
        }
        PlayerGame playerGame = optionalPlayerGame.get();
        // Get the PlayerGame and check it isn't null

        if(playerGame.getHandicap() == null) playerGame.setHandicap(playerGame.getPlayer().getHandicap());
        // Lock in playerGame handicap if not set as current player handicap

        Score savedScore = repo.save(new Score(playerGame, score.getScratch(), score.getHandicap() != null ? score.getHandicap() : playerGame.getHandicap()));
        // Save score with the playerGame, the scratch, and get the handicap from scoreRest if it has it
        // Otherwise take it from playerGame

        playerGame.addScore(savedScore);
        playerGameRepository.save(playerGame);
        // Add score to playerGame and save it

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest().path("/{id}")
                .buildAndExpand(savedScore.getId()).toUri();
        return ResponseEntity.created(location).build();
        // Construct and return delete URI
    }

    @RequestMapping(value = "/api/score/{id}", method = RequestMethod.DELETE)
    public ResponseEntity<Void> deleteScore(@PathVariable Long id) {
        Optional<Score> optionalScore = repo.findById(id);
        if (! optionalScore.isPresent()){
            return ResponseEntity.notFound().build();
        }
        Score score = optionalScore.get();
        // Get score and check it isn't null

        score.getPlayerGame().deleteScore(score);
        playerGameRepository.save(score.getPlayerGame());
        // Remove score from playerGame and save the change

        repo.deleteById(id);
        return ResponseEntity.noContent().build();
        // Delete and return a 204
    }
}

----

==== ScoreRest.java
We need to get the data still, so another Rest object will help.

[source, java]
----
package com.saskcow.bowling.rest;

import ...

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ScoreRest {
    private Long playerGameId;
    private Integer scratch;
    private Integer handicap;
    // Only needs the playerGameId, scratch, and handicap as scores added later

    public ScoreRest(Long playerGameId, Integer scratch){
        this.playerGameId = playerGameId;
        this.scratch = scratch;
    }
    // Can be constructed with no handicap if none specified
}
----

==== AddScore.js
Need to add scores, this will be contained in a cell in the table.

[source, jsx]
----
import ...

class AddScore extends React.Component{
  constructor(props) {
    super();
    this.state = ({id: props.id, scratch: "", handicap: "", checkHandicap: false});
    this.handleUserInput = this.handleUserInput.bind(this);
    this.submit = this.submit.bind(this);
    // Set default state and bind this to functions
  }

  handleUserInput (event) {
    this.setState({[event.target.name]: event.target.value});
  }
  // handle any inputs by setting targetName: targetValue

  submit(event) {
    event.preventDefault();
    // Prevent default form submitting behaviour
    axios.post("/api/score", {
      playerGameId: this.state.id,
      scratch: this.state.scratch,
      handicap: this.state.checkHandicap ? this.state.handicap : null
    })
    // Send a post request with the necessary components, don't send handicap unless box checked
      .then(response => {
        location.reload();
        // Reload page if successful
        console.log("created at " + response.headers.location);
      })
      .catch(error => {
        if(error.response && error.response.status === 401){
          window.location.href = '/login';
        } else if(error.response && error.response.status === 400){
          this.setState({err: "Invalid Data"});
          // If 400, suggests user has invalid data, like out of range numbers
        } else {
          console.log(error)
        } // Login redirecting and simple ish error handling
      });
  }

  render() {
    return (
      <div className={this.props.name + "-AddScreen"}>
        <form className={this.props.name + "-theScoreForm"} onSubmit={this.submit} noValidate>
          {/*Create a form which when submitted calls submit*/}

          <TextField
            id={this.props.name + "-scratch"}
            name="scratch"
            label="Scratch"
            fullWidth={true}
            value={this.state.scratch}
            onChange={this.handleUserInput}
            type="number"
            className={"scratch"}
            InputLabelProps={{
              shrink: true,
            }}
            margin="normal"
          />
          {/*Create a text input which updates scratch and is a number input, restricts letter entering*/}

          <TextField
            id={this.props.name + "-handicap"}
            name="handicap"
            label="Override handicap"
            fullWidth={true}
            value={this.state.handicap}
            onChange={this.handleUserInput}
            type="number"
            className={"handicap"}
            InputLabelProps={{
              shrink: true,
            }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Checkbox
                    checked={this.state.checkHandicap}
                    onChange={this.handleUserInput}
                    name="checkHandicap"
                    id={this.props.name + "-checkHandicap"}
                    value="val"
                    color="primary"
                  />
                </InputAdornment>
              ),
            }}
            margin="normal"
          />
          {/*Another input this time for handicap overrides*/}
          {/*Has an InputAdornment, which is at the right, and is a checkbox, when checked, handicap overridden*/}

          <br/>

          <Button id={this.props.name + '-submit'} type={"submit"} variant={"raised"} color={"primary"} className={"submitForm"}>Submit</Button>
          {/*Submit button*/}

        </form>
        <p className={"errorMessage"}>{this.state.err}</p>
        {/*Show errors*/}
      </div>
    )
  }
}

export default AddScore; // Easier imports elsewhere
----

==== Game.js
Where else would we add scores, more adding to Game.js time!

[source, jsx]
----
tables.push(
<React.Fragment key={i + "-empty"}>
  {(this.state.game.playerGames.length === 6 && i !== 0) && <br/>}
  <table key={i} id={this.state.game.teams[i].name.replace(/\s+/g, '-').toLowerCase()}>
    <thead>
    <tr>
      <th colSpan={10}>{this.state.game.teams[i].name}</th>
      <th>score</th>
    </tr>
    <tr>
      <th width="10%">HCP</th>
      <th width="40%">Bowler</th>
      <th width="10%" colSpan={2}>Game 1</th>
      <th width="10%" colSpan={2}>Game 2</th>
      <th width="10%" colSpan={2}>Game 3</th>
      <th width="10%" colSpan={2}>Total</th>
      <th width="10%">Pts</th>
    </tr>
    </thead>
    {this.state.game.playerGames.slice(3 * i, 3 * i + 3).map(playerGame => (
      this.genScores(playerGame)
    ))}
    {/*Make 3 genScores, use index 0->3 or 3->6 dependent on first or second team*/}
  </table>
</React.Fragment>
)

// table() in main tables.push, now sources data from genScores which makes the rows of data

genScores(playerGame) {
  if(playerGame.scores.length < 3) {
    // If it's not full
    let i = 0;
    const data = [[
      <React.Fragment key={playerGame.id + "-player"}>
        <td rowSpan={2}>{playerGame.handicap}</td>
        <td rowSpan={2}>{playerGame.player.name}</td>
      </React.Fragment>]];
    // Create data, an array of arrays, data[x][0] is for row 1 of table, data[x][1] is for row 2
    // Fill data with the player details as 2 tall
    playerGame.scores.forEach(score => {
      i++; // Increment i
      data.push([
        <React.Fragment key={score.id}>
          <td key={score.id + "-scratch"}>{Number.isInteger(score.scratch) ? score.scratch : ""}</td>
          <td key={score.id + "-handicapped"}>{Number.isInteger(score.handicapped) ? score.handicapped : ""}</td>
        </React.Fragment>, // Add cell with the scratch and handicap for each score
        <td colSpan={2} key={score.id + "-score"}>{score.score ? score.score : ""}</td>
        // Also add the points awarded below
      ])
    });
    if (this.state.game.playerGames.length === 6){
      // If the game has all the playerGames
      data.push([
        <td colSpan={2} rowSpan={2} key={playerGame.id + "-addScore"}>
          <AddScore id={playerGame.id} name={playerGame.player.name.replace(/\s+/g, '-').toLowerCase()}/>
        </td>]);// Add an AddScore, so a user can input a score
    } else {
      data.push([
        <React.Fragment key={playerGame.id + "-" + "would-be-j"}>
          <td key={"would-be-j" + "-0"}/>
          <td key={"would-be-j" + "-1"}/>
        </React.Fragment>,
        <td key={"would-be-j" + "-2"} colSpan={2} />
      ]);// Otherwise add empty space, scores shouldn't be added before both teams are in the game
    }
    for (let j = i; j<2; j++) {
      data.push([
        <React.Fragment key={playerGame.id + "-" + j}>
          <td key={j + "-0"}/>
          <td key={j + "-1"}/>
        </React.Fragment>,
        <td key={j + "-2"} colSpan={2} />
      ]);
    }
    // Fill with empty till row full of empty scores
    data.push([
      <React.Fragment key={playerGame.id + "-totals"}>
        <td>totals</td>
        <td>totals</td>
        <td rowSpan={2}>Points</td>
      </React.Fragment>,
      <td key={playerGame.id + "-scoreTotals"} colSpan={2}>totals</td>]);
    // Add totals, like blank but with word totals in, so we know where the totals will be when calculated
    return (
      <tbody key={playerGame.id + "-table"}>
      <tr>
        {data.map(thing => thing[0])}
      </tr>
      <tr>
        {data.map(thing => thing[1])}
      </tr>
      </tbody>
      // Return the 2 rows wrapped in a tbody
    )
  } else {
    return (
      // If it's full of scores, just send this, nice and easy
      <tbody id={playerGame.player.name.replace(/\s+/g, '-').toLowerCase() + "-full"} key={playerGame.id + "-full"}>
      <tr>
        <td rowSpan={2}>{playerGame.handicap}</td>
        <td rowSpan={2}>{playerGame.player.name}</td>
        <td>{playerGame.scores[0] !== null ? playerGame.scores[0].scratch : ""}</td>
        <td>{playerGame.scores[0] !== null ? playerGame.scores[0].handicapped : ""}</td>
        <td>{playerGame.scores[1] !== null ? playerGame.scores[1].scratch : ""}</td>
        <td>{playerGame.scores[1] !== null ? playerGame.scores[1].handicapped : ""}</td>
        <td>{playerGame.scores[2] !== null ? playerGame.scores[2].scratch : ""}</td>
        <td>{playerGame.scores[2] !== null ? playerGame.scores[2].handicapped : ""}</td>
        <td>totals</td>
        <td>totals</td>
        <td rowSpan={2}>Points</td>
      </tr>
      <tr>
        <td colSpan={2}>{playerGame.scores[0] !== null ? playerGame.scores[0].score : ""}</td>
        <td colSpan={2}>{playerGame.scores[1] !== null ? playerGame.scores[1].score : ""}</td>
        <td colSpan={2}>{playerGame.scores[2] !== null ? playerGame.scores[2].score : ""}</td>
        <td colSpan={2}>totals</td>
      </tr>
      </tbody>
    )
  }
}
// That's all the changes for now
----

==== Errors at this stage
Errors occurred, but all had been seen before, so we have aesthetic errors now.

===== Table Cells
I don't like how stretched the cells look with the score form in, however I am yet to find a better way to do it.
So it looks like this.
.Takes up a lot of space on the page.
image::dev-pictures/add-scores.png[addScores, pdfwidth=100%]

=== A player can add their handicap to a game
Completed alongside AddScores, as it was the best time to do it

=== Added Score is adjusted for handicap
Wrote it in the backend when adding score, so it's done.

=== Points are awarded for a complete Game
This one, not done yet. So what needs to be done to complete a game, usually it is preferred if I add flowcharts.

.Scoring Flowchart
image::dev-pictures/scoring-flowchart.png[scoringFlowchart, pdfwidth=100%]

It won't be exactly like this as adding scores is not as easy as immediately obvious as object + object =
operator + cannot be applied to score. So some lambda functions will reduce down the lists and objects into one Integer.

A game will need to be completed at a point. This should be decided by the user and thus should have it's REST end point.
It is not obvious which method should be used as it isn't submitting much data for a `post` request, but doesn't fit `put`, (Upload a representation of the object)
either. Since it modifies state it shouldn't be a `get` request either. Therefore a `post` request is used.

==== GameControllerTest.java
More controllers, this test is really large as it needs to make all the objects which would be in place for a complete game.
It then also needs to make sure they are correctly linked.

[source, java]
----
@Test
public void completeGame_shouldCompleteGame() throws Exception {
    League cityWatch = new League(1L, "City Watch", null, new LinkedList<>());
    cityWatch.setRota(new Rota(cityWatch));
    // Create a league and rota

    Team cableStreet = new Team(1L, "Cable Street Particulars", null, new LinkedList<>(), cityWatch, new LinkedList<>());
    Team nightWatch = new Team(2L, "The Night Watch", null, new LinkedList<>(), cityWatch, new LinkedList<>());
    // Add teams to leagues

    cableStreet.setPlayers(new LinkedList<>(Arrays.asList(
            new Player(1L, "Findthee Swing", cableStreet, new LinkedList<>()),
            new Player(2L, "Carcer", cableStreet, new LinkedList<>()),
            new Player(3L, "Gerald Leastways, a.k.a. Ferret", cableStreet, new LinkedList<>()),
            new Player(4L, "Henry 'The Hamster' Higgins", cableStreet, new LinkedList<>())
    )));
    nightWatch.setPlayers(new LinkedList<>(Arrays.asList(
            new Player(5L, "Sam Vimes", nightWatch, new LinkedList<>()),
            new Player(6L, "Carrot Ironfoundersson", nightWatch, new LinkedList<>()),
            new Player(7L, "Nobby Nobbs", nightWatch, new LinkedList<>()),
            new Player(8L, "Fred Colon", nightWatch, new LinkedList<>())
    )));

    // Add 4 players to each game

    Game game = new Game(1L, cityWatch.getRota(), LocalDateTime.now(Clock.systemUTC()), "The Shades", Arrays.asList(cableStreet, nightWatch), new LinkedList<>());
    cableStreet.addGame(game);
    nightWatch.addGame(game);
    // Create a game, add it to both teams

    PlayerGame swingGame = new PlayerGame(1L, cableStreet.getPlayers().get(0), cableStreet, game, new LinkedList<>(), null);
    PlayerGame carcerGame = new PlayerGame(2L, cableStreet.getPlayers().get(1), cableStreet, game, new LinkedList<>(), null);
    PlayerGame geraldGame = new PlayerGame(3L, cableStreet.getPlayers().get(2), cableStreet, game, new LinkedList<>(), null);
    // Create a PlayerGame for the 3 participating in the game

    cableStreet.addAllPlayerGame(Arrays.asList(swingGame, carcerGame, geraldGame));
    game.addAllPlayerGame(Arrays.asList(swingGame, carcerGame, geraldGame));
    cableStreet.getPlayers().get(0).addPlayerGame(swingGame);
    cableStreet.getPlayers().get(1).addPlayerGame(carcerGame);
    cableStreet.getPlayers().get(2).addPlayerGame(geraldGame);
    // Add playerGames to the appropriate games, teams or players

    PlayerGame samGame = new PlayerGame(4L, nightWatch.getPlayers().get(0), nightWatch, game, new LinkedList<>(), null);
    PlayerGame carrotGame = new PlayerGame(5L, nightWatch.getPlayers().get(1), nightWatch, game, new LinkedList<>(), null);
    PlayerGame nobbyGame = new PlayerGame(6L, nightWatch.getPlayers().get(2), nightWatch, game, new LinkedList<>(), null);
    // Create a PlayerGame for the 3 participating in the game

    nightWatch.addAllPlayerGame(Arrays.asList(samGame, carrotGame, nobbyGame));
    game.addAllPlayerGame(Arrays.asList(samGame, carrotGame, nobbyGame));
    nightWatch.getPlayers().get(0).addPlayerGame(samGame);
    nightWatch.getPlayers().get(1).addPlayerGame(carrotGame);
    nightWatch.getPlayers().get(2).addPlayerGame(nobbyGame);
    // Add playerGames to the appropriate games, teams or players

    when(repo.findById(game.getId())).thenReturn(Optional.of(game));
    // When trying to find the game, return the game as an Optional

    mockMvc.perform(post("/api/game/1"))
            .andExpect(status().isBadRequest());
    // Check a game with no scores gets a 404 send back

    IntStream.range(0, 3).forEach(i -> swingGame.addScore(new Score((long) i, swingGame, 100 + 10*i, 100 + 10*i + 15, null)));
    IntStream.range(0, 3).forEach(i -> carcerGame.addScore(new Score((long) i + 3, carcerGame, 100 - 10*i, 100 - 10*i + 25, null)));
    IntStream.range(0, 3).forEach(i -> geraldGame.addScore(new Score((long) i + 6, geraldGame, 100 + 5*i, 100 + 5*i + 20, null)));
    IntStream.range(0, 3).forEach(i -> samGame.addScore(new Score((long) i + 9, samGame, 100 + (4*i*i), 100 + (4*i*i) + 15, null)));
    IntStream.range(0, 3).forEach(i -> carrotGame.addScore(new Score((long) i + 12, carrotGame, 100, 100 + 25, null)));
    IntStream.range(0, 3).forEach(i -> nobbyGame.addScore(new Score((long) i + 15, nobbyGame, (int) (100 + pow(-5*i, i)), (int) (100 + pow(-5*i, i)) + 20, null)));
    // Add the scores, with some variation of scores for each so some are equal, some higher, some lower

    mockMvc.perform(post("/api/game/1"))
            .andExpect(status().isNoContent());
    // Check a no content is returned when game complete sent

    assertThat(game.getPlayerGames().stream().allMatch(playerGame -> playerGame.getScores().stream().allMatch(score -> score.getScore() != null))).isTrue();
    // Check that for every player in the game, every score they have, the points awarded is not null anymore
    assertThat(game.getPlayerGames().stream().allMatch(playerGame -> playerGame.getScores().size() == 4)).isTrue();
    // Check that every player in the game has 4 scores
    assertThat(game.getPlayerGames().size()).isEqualTo(8);
    // Check that there are 8 players, 6 people, 2 totals
    assertThat(nightWatch.getPlayerGames().size()).isEqualTo(4);
    // Check nightwatch has all 4 playerGames
    assertThat(cableStreet.getPlayerGames().size()).isEqualTo(4);
    // Check cablestreet has all 4 playerGames

}
----

==== GameController.java
This was added

[source, java]
----
@RequestMapping(value = "/api/game/{id}", method = RequestMethod.POST)
// All post requests to a specific game
public ResponseEntity<?> endGame(@PathVariable Long id) {
    // Take id from path
    Optional<Game> optionalGame = repo.findById(id);
    if (! optionalGame.isPresent()){
        return ResponseEntity.notFound().build();
    }
    Game game = optionalGame.get();
    // Get the game, and check it really exists, otherwise send back a 404
    if (game.getPlayerGames().size() != 6 || ! game.getPlayerGames().stream().allMatch(playerGame -> playerGame.getScores().size() == 3)){
        return ResponseEntity.badRequest().build();
    }
    // If there are not 6 players in the game, or any of the playerGames do not have 3 scores, send back a 400
    game.completeGame();
    // Call game complete function
    repo.save(game);
    // Save changes, many cascades set so it saves all transients too
    return ResponseEntity.noContent().build();
    // Return 204
}
----

Sadly all the logic is in

==== Game.java
Here! The following 4 functions were added.

[source, java]
----
public void completeGame() {
    this.playerGames.add(3, new PlayerGame(null, this.teams.get(0), this));
    this.playerGames.add(new PlayerGame(null, this.teams.get(1), this));
    // Add the playerGames for total players, do not have a player, just a team as it is sum of all on a team.
    this.addTotalPlayer();
    // Call addTotalPlayer to fill in scores for these new total players
    this.getScores();
    // Get the totals for each player in game
    this.addPoints();
    // Assign points
}


private void addTotalPlayer() {
    List<PlayerGame> list1 = this.playerGames.subList(0, 3);
    // Team 1's playerGames (not total)
    List<PlayerGame> list2 = this.playerGames.subList(4, 7);
    // Team 2's playerGames (not total)
    this.playerGames.get(3).setScores(new LinkedList<>(
            // Set scores to a list with the following
            IntStream.range(0, 3).mapToObj(i -> {
                    // For i in range(3) create an object
                    Integer scratchSum = list1.stream().reduce(0,
                            (a, b) -> a + b.getScores().get(i).getScratch(),
                            (a, b) -> a + b);
                    // Get sum of scratch scores, default 0 if empty
                    // Accumulate by adding accumulator Integer to the score of the i th game of each player
                    return (new Score(playerGames.get(3),
                            scratchSum, // Create a new score for the totalPlayer with this scratch score (the total)
                            list1.stream().reduce(0,
                                    (a, b) -> a + b.getScores().get(i).getHandicapped(),
                                    (a, b) -> a + b) - scratchSum)
                            // Get the handicapped and subtract the scratchSum to calculate the effective handicap for the set
                    );
            }).collect(Collectors.toList())
            // Collect the scores into a list
    ));

    this.playerGames.get(7).setScores(new LinkedList<>(
            IntStream.range(0, 3)
                    .mapToObj(i -> {
                        Integer x = list2.stream().reduce(0,
                                (a, b) -> a + b.getScores().get(i).getScratch(),
                                (a, b) -> a + b);
                        return (new Score(playerGames.get(7),
                                x,
                                list2.stream().reduce(0,
                                        (a, b) -> a + b.getScores().get(i).getHandicapped(),
                                        (a, b) -> a + b) - x)
                        );
                    }).collect(Collectors.toList())
    ));
    // Do the same for the second totalPlayerGame

    this.teams.get(0).addPlayerGame(this.playerGames.get(3));
    this.teams.get(1).addPlayerGame(this.playerGames.get(7));
    // Add them to their respective teams
}


private void getScores() {
    // Add total Scores
    this.playerGames.forEach(playerGame -> playerGame.addScore(new Score(
            // For every playerGame, add a score
            playerGame,
            // For that playerGame
            playerGame.getScores().stream().reduce(0, (a, b) -> a + b.getScratch(), (a, b) -> a + b),
            // With the total of all their scratch scores
            // Add all score.getScratch() for each score
            playerGame.getScores().stream()
                    .reduce(0,
                            (a, b) -> a + b.getHandicapped(), (a, b) -> a + b) -
                    playerGame.getScores().stream()
                            .reduce(0, (a, b) -> a + b.getScratch(), (a, b) -> a + b)
            // Do the same handicapped - scratch to get a total handicap for the game, done this way in case custom handicap used for a set
            , true // Set totalScore to true
    )));
    // Fairly short and simple, just adding another score with the total scratch and handicapped for each player in game
}


private void addPoints() {
    // Zip List
    List<List<PlayerGame>> zipped = IntStream.range(0, 4)
            .mapToObj(i -> Arrays.asList(this.playerGames.get(i), this.playerGames.get(i + 4)))
            .collect(Collectors.toList());
    // Since there are 8 games, match them all up to the opposite teams equivalent
    // Usually I would use zip(first half, second half) but Java 8 has no built in zip function
    // So for x in range(4) create a list with the x and x + 4 players

    zipped.forEach(thing -> {
        // Zip Scores
        // For each list of 2 playerGames
        List<Score> scores0 = thing.get(0).getScores();
        List<Score> scores1 = thing.get(1).getScores();
        // Assign the scores to variables
        List<List<Score>> zippedScores = IntStream.range(0, 4)
                .mapToObj(i -> Arrays.asList(scores0.get(i), scores1.get(i)))
                .collect(Collectors.toList());
        // Zip team 1's player's scores against team 2's player's scores
        // For each player 1 score, create a list with the corresponding player 2 score

        // Compare each score against the other
        zippedScores.forEach(scores -> {
            if (scores.get(0).getHandicapped().equals(scores.get(1).getHandicapped())) {
                scores.get(0).setScore(1);
                scores.get(1).setScore(1);
                // If both scores are the same, both get one point
            } else if (scores.get(0).getHandicapped() > scores.get(1).getHandicapped()){
                scores.get(0).setScore(2);
                scores.get(1).setScore(0);
                // If team 1's player has higher score, give the score 2 points, give the other 0
            } else {
                scores.get(0).setScore(0);
                scores.get(1).setScore(2);
                // If team 2's player has higher score, give the score 2 points, give the other 0
            }
        });
    });
}
----

That's the 3 steps implemented!

=== Winning Team Displayed
The client gave feedback that it's great that the points are added. But he also wanted them displayed for some reason.
So here they are getting displayed as part of showing the winner.

==== Game.js
[source, jsx]
----
table() {
  if(this.state.game.playerGames.length !== 8){
    ...
  } else {
    let tables = [];
    const teamTotals = [this.state.game.playerGames.slice(0, 4).reduce((a, b) => a + b.scores.reduce((a, b) => a + b.score, 0), 0),
      this.state.game.playerGames.slice(4, 8).reduce((a, b) => a + b.scores.reduce((a, b) => a + b.score, 0), 0)];
    // Total score for each team added to teamTotals, calculated by adding all up the sum of playerGames scores for a team
    for(let i = 0; i<2; i++) {
      // Do this twice
      tables.push(
        <React.Fragment key={i + "-fragment"}>
          {i !== 0 && <br/>}
          <table key={i} id={this.state.game.teams[i].name.replace(/\s+/g, '-').toLowerCase()} className={teamTotals[i] > teamTotals[(i + 1) % 2] ? "winner" : "loser"}>
            {/*Create a table, if the teams score is higher than the opposition, they get the winner class, otherwise they are losers*/}
            <thead>
            <tr>
              <th colSpan={10}>{this.state.game.teams[i].name}</th>
              <th>{teamTotals[i]}</th>
            </tr>
            {/*Add Team Header*/}
            <tr>
              <th width="10%">HCP</th>
              <th width="40%">Bowler</th>
              <th width="10%" colSpan={2}>Game 1</th>
              <th width="10%" colSpan={2}>Game 2</th>
              <th width="10%" colSpan={2}>Game 3</th>
              <th width="10%" colSpan={2}>Total</th>
              <th width="10%">Pts</th>
            </tr>
            {/*Titles*/}
            </thead>
            {this.state.game.playerGames.slice(4 * i, 4 * i + 4).map(playerGame => {
              return Game.genFullScores(playerGame);
            })}
            {/*Add the result of genFullScores for each playerGame of the team*/}
          </table>
        </React.Fragment>);
    //  Add this to tables
    }
    return tables;
  }
}


static genFullScores(playerGame) {
  // Generate scores for a complete game static as doesn't reference this
  return (<tbody key={playerGame.id + "-full"}>
  <tr>
    <td rowSpan={2}>{Number.isInteger(playerGame.handicap) ? playerGame.handicap: ""}</td>
    <td rowSpan={2}>{playerGame.player ? playerGame.player.name: ""}</td>
    <td>{playerGame.scores[0].scratch}</td>
    <td>{playerGame.scores[0].handicapped}</td>
    <td>{playerGame.scores[1].scratch}</td>
    <td>{playerGame.scores[1].handicapped}</td>
    <td>{playerGame.scores[2].scratch}</td>
    <td>{playerGame.scores[2].handicapped}</td>
    <td>{playerGame.scores[3].scratch}</td>
    <td>{playerGame.scores[3].handicapped}</td>
    <td rowSpan={2}>{playerGame.scores.reduce((a, b) => a + b.score, 0)}</td>
    {/*Create a row with 4 player Scores and the total points*/}
    {/*No type checking as these should always be in a complete game*/}
  </tr>
  <tr>
    <td colSpan={2}>{playerGame.scores[0].score}</td>
    <td colSpan={2}>{playerGame.scores[1].score}</td>
    <td colSpan={2}>{playerGame.scores[2].score}</td>
    <td colSpan={2}>{playerGame.scores[3].score}</td>
    {/*Add the points underneath*/}
  </tr>
  </tbody>)
}
----

This adds to the table function that if it has 8 playerGames, it must be complete, handle it differently.
genFullScores gives the values for each player in a game.

As well as this a ScoreGame button is added if table has 6 players and all have 3 scores
[source, jsx]
----
if (this.state.game.playerGames.length === 6 && this.state.game.playerGames.every(playerGame => playerGame.scores.length === 3)) {
  tables.push(<Button variant={"raised"} color={"primary"} key={'scoreGame'} id={"scoreGame"} onClick={this.scoreGame}>Score Game</Button>)
}
----

==== How does it look

.Button on a full Game
image::dev-pictures/full-unscored.png[fullUnscored, pdfWidth=100%]

.Complete Game
image::dev-pictures/full-scored.png[fullScored, pdfWidth=100%]

Shows in green and red thanks to
[source, css]
----
table[class~=winner] th {
    background: limegreen;
}
/* headings in winner tables are limegreen */

table[class~=loser] th {
    background-color: red;
}
/* headings in loser tables are red */
----

The winner is now clear from the table.

==== Errors at this stage

===== Missing Links
When totalPlayerGames are created, they are linked to a team. Without this link, when trying to access team games, the total
objects are missing from teams. This is not ideal.

image::error-pictures/Expected 4 was 3.png[expected4Was3, pdfwidth=50%]

Just adding the `this.teams.get(0).addPlayerGame(this.playerGames.get(3));` and `this.teams.get(1).addPlayerGame(this.playerGames.get(7));`
fixed this.

===== Reduce syntax
In javascript, the reduce syntax is very different.
This meant that originally the `(a, b) -> a + b` was not present as it is not used in javascript.
In java it is required so was added to stop

image::error-pictures/streams not that easy.png[reduceSyntaxDifferent.png, pdfWidth=100%]

=== Highest Score is 300
In one of the examples I showed the client, I added a score over 300. Now apparently that shouldn't happen.
So now I need to make sure it doesn't.

==== ScoreController.java

[source, java]
----
if (! optionalPlayerGame.isPresent() || 0 > score.getScratch() || score.getScratch() > 300){
    return ResponseEntity.badRequest().build();
}
----
Is now in place instead of just `! optionalPlayerGame.isPresent()`, so any under 0 or over 300 scores are rejected with a `404`.

==== Errors at this Stage
As complex as this was, there weren't any errors!

=== Calculate Player Handicap
Now the player's past scores should influence the handicap so handicap = `INT(((200-INT(bowler_average))*0.8)`
of the last 24 games

==== Player.java
As a placeholder previously

[source, java]
----
public integer getHandicap(){
    return 2
}
----
was in place. Apparently that wasn't quite `INT(((200-INT(bowler_average))*0.8)` so now

[source, java]
----
public Integer getHandicap(){
    if (this.playerGames == null){return 0;}
    // If there are no games, return 0 as handicap
    List<PlayerGame> last24 = this.playerGames.stream()
            .filter(playerGame -> playerGame.getScores().size() == 3 || playerGame.getScores().size() == 4)
            .collect(Collectors.toList());
            // Collect all the playerGames where the game is complete or player has bowled all
    last24 = last24.subList(last24.size() - 24 >= 0 ? last24.size() - 24 : 0, last24.size());
    // Get the last 24 of these games
    if (last24.size() == 0){return 0;}
    // If it's empty, return 0 as handicap
    Integer handicap = last24.stream().reduce(0,
            (a, b) -> a + (b.getScores().subList(0, 3).stream()
                    .reduce(0, (c, d) -> c + d.getScratch(), (c, d) -> c + d)/3),
            (a, b) -> a + b)/last24.size();
    // Get the total scratch for each game and divide it by the number of games to get average
    handicap = 200 - Math.floorDiv(4 * handicap, 5);
    // x * 0.8 = x / (5/4) = 4*x / 5
    // Set handicap to 200 - INT(0.8*bowler average) effectively
    if (handicap < 0) {
        return 0;
        // If under 0, return 0 as minimum handicap
    } else if (handicap > 80) {
        return 80;
        // If over 80 return 80 as max handicap
    } else {
        return handicap;
        // Otherwise return the calculated handicap
    }
}
----

Since the placeholder was already in, it now all works!

=== Generate and display Player stats
Due to the potentially large volume of data which could be reduced if done via reduce, it is likely faster
to use database queries to collect the data.

==== PlayerRepositoryTest.java
So that it can check if it has the right values when writing the queries.

[source, java]
----
package com.saskcow.bowling.repository;

import ...

@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = {BowlingApplication.class})
@ActiveProfiles("test")
public class PlayerRepositoryTest {

    @Autowired
    // Get a playerRepository from context
    private PlayerRepository playerRepository;
    // Have swing for everything in class as the player
    private Player swing;

    @Before
    public void populate() {
        Player swing = new Player("Findthee Swing", null);
        // Create swing
        swing.addPlayerGame(new PlayerGame(swing, null, null));
        // Create swing game
        swing.getPlayerGames().get(0).setScores(new LinkedList<>(Arrays.asList(
                new Score(swing.getPlayerGames().get(0), 45, 2),
                new Score(swing.getPlayerGames().get(0), 22, 2),
                new Score(swing.getPlayerGames().get(0), 32, 2),
                new Score(swing.getPlayerGames().get(0), 99, 6, true)
        )));
        // Add scores
        swing.addPlayerGame(new PlayerGame(swing, null, null));
        // Create another game
        swing.getPlayerGames().get(1).setScores(new LinkedList<>(Arrays.asList(
                new Score(swing.getPlayerGames().get(1), 43, 2),
                new Score(swing.getPlayerGames().get(1), 37, 2),
                new Score(swing.getPlayerGames().get(1), 42, 2),
                new Score(swing.getPlayerGames().get(1), 122, 6, true)
        )));
        // Add more scores
        this.swing = playerRepository.save(swing);
        // Save swing into repository
    }

    @Test
    public void highGame() {
        assertThat(playerRepository.highGame(swing.getId())).isEqualTo(45);
        // highGame should be 45
    }

    @Test
    public void highSeries() {
        assertThat(playerRepository.highSeries(swing.getId())).isEqualTo(122);
        // highSeries should be 122
    }

    @Test
    public void lowGame() {
        assertThat(playerRepository.lowGame(swing.getId())).isEqualTo(22);
        // lowGame should be 22
    }

    @Test
    public void lowSeries() {
        assertThat(playerRepository.lowSeries(swing.getId())).isEqualTo(99);
        // lowSeries should be 99
    }
}
----

==== PlayerRepository.java
Queries to access the database and use aggregate functions. Defined in body of PlayerRepository.

[source, java]
----
// Get the highest scratch achieved in one game of bowling
@Query("SELECT MAX(s.scratch) FROM Player p JOIN p.playerGames pg JOIN pg.scores s WHERE p.id = :id AND s.total = FALSE")
// For every score in every playergame a player has which isn't a total Score, return the highest scratch score
Integer highGame(Long id);
// Function to call which takes an id and passes it into :id in the query

// Get the highest scratch total in one series
@Query("SELECT MAX(s.scratch) FROM Player p JOIN p.playerGames pg JOIN pg.scores s WHERE p.id = :id AND s.total = TRUE ")
// For every score in every playerGame a okayer has which is a total Score, return the highest scratch score
Integer highSeries(Long id);
// Function to call which takes an id and passes it into :id in the query

// Get the lowest scratch achieved in one game of bowling
@Query("SELECT MIN(s.scratch) FROM Player p JOIN p.playerGames pg JOIN pg.scores s WHERE p.id = :id AND s.total = FALSE")
// For every score in every playergame a player has which isn't a total Score, return the lowest scratch score
Integer lowGame(Long id);
// Function to call which takes an id and passes it into :id in the query

// Get the lowest scratch total in one series
@Query("SELECT MIN(s.scratch) FROM Player p JOIN p.playerGames pg JOIN pg.scores s WHERE p.id = :id AND s.total = TRUE ")
// For every score in every playerGame a okayer has which is a total Score, return the lowest scratch score
Integer lowSeries(Long id);
// Function to call which takes an id and passes it into :id in the query
----

IMPORTANT: The queries are not SQL queries, but JPQL, a similar language for JPA.

==== Learning JPQL
Many attempts at writing these queries were made. Partly as my SQL wasn't great, let alone my JPQL.
_versions of highGame_
[source, sql]
----
SELECT MAX(p.playerGames.scores.scratch) FROM Player p WHERE p.id = :id;
-- Failed particularly badly, cannot load application context, something is probably wrong

SELECT MAX(SELECT MAX(SELECT MAX(s.score) FROM Score s WHERE s.playerGame.id = pg.id) FROM PlayerGames pg WHERE pg.player.id = :id) FROM Player p WHERE p.id = :id;
-- This was a mistake, nested queries don't work so good here, application context fails to load

-- Here I found about how JOIN worked in JPA, there are many types of JOIN, thankfully just JOIN worked here
SELECT MAX(s.scratch) FROM Player p JOIN p.playerGames pg JOIN pg.scores s WHERE p.id = :id AND s.total = FALSE;
-- Final Version
----

From here everything was a minor variation on what existed.

==== PlayerView.java
Now has far more details about a player.

[source, java]
----
private Integer handicap;
private List<PlayerGameViewSummary> recentGames;
private Integer highGame;
private Integer lowGame;
private Integer highSeries;
private Integer lowSeries;
// Add spaces for data from new queries

if (player.getPlayerGames() != null) {
    List<PlayerGame> last6 = player.getPlayerGames().stream()
            .filter(playerGame -> playerGame.getScores().size() == 4)
            .collect(Collectors.toList());
    this.recentGames = last6.subList(last6.size - 6 >= 0 ? last6.size - 6 : 0, last6.size(): last6.size()).stream().map(PlayerGameViewSummary::new).collect(Collectors.toList());
}
// Get last 6 complete games and make them all into PlayerGameViewSummary
----

==== PlayerGameViewSummary.java
Players don't need every piece of information, what they need is fairly brief

[source, java]
----
package com.saskcow.bowling.view;

import ...

@Data
@NoArgsConstructor
// Standard add a constructor and getters and setters
public class PlayerGameViewSummary {
    private Long id;
    private Long gameId;
    private LocalDateTime date;
    private TeamViewSummary opposition;
    private List<ScoreViewSummary> scores;
    // Has an id, a gameId, a date, an opposition, and the scores

    public PlayerGameViewSummary(PlayerGame playerGame) {
        this.id = playerGame.getId();
        this.gameId = playerGame.getGame().getId();
        this.date = playerGame.getGame().getTime();
        this.opposition = new TeamViewSummary(playerGame.getGame().getTeams().get((playerGame.getGame().getTeams().indexOf(playerGame.getTeam()) + 1) % 2));
        // Get the other team in the game
        this.scores = playerGame.getScores().stream().map(ScoreViewSummary::new).collect(Collectors.toList());
        // Get the details from playerGames
    }
}
----

==== PlayerController.java
The data isn't got from a player anymore, but the repository, so it needs to be added.

[source, java]
----
@RequestMapping(value = "/api/player/{id}", method = RequestMethod.GET)
public ResponseEntity<PlayerView> findPlayer(@PathVariable("id") Long id) {
    Optional<Player> optionalPlayer = repo.findById(id);
    if(! optionalPlayer.isPresent()){
        return ResponseEntity.notFound().build();
    }
    Player player = optionalPlayer.get();
    PlayerView playerView = new PlayerView(player);
    playerView.setHighGame(repo.highGame(player.getId()));
    playerView.setHighSeries(repo.highSeries(player.getId()));
    playerView.setLowGame(repo.lowGame(player.getId()));
    playerView.setLowSeries(repo.lowSeries(player.getId()));
    return ResponseEntity.ok(playerView);
}
----

Now for each statistic it is filled in from the repository then sent to the front end.

==== Player.js
Now the front end should show the information.
I decided to make it a table as there is a lot of tabular data and it would be a clear and easy way to display it all.
I decided that I wanted the player details, stats and recent games in one table

[source, jsx]
----
import ...

class Player extends React.Component {
// Create component Player

  constructor(props) {
    super();
    this.state = {status: "Loading"};
    // Set default state
    this.getPlayer = this.getPlayer.bind(this);
    this.getPlayer(props.match.params.id);
  //  Bind this to getPlayer and call it with the id
  }

  getPlayer(id) {
    axios.get('/api/player/' + id)
      // Send get request to /api/player/{player id}
      .then(response => {
        // When complete
        this.setState({
          status: "OK",
          id: id,
          name: response.data.name,
          team: response.data.team,
          handicap: response.data.handicap,
          recentGames: response.data.recentGames,
          highGame: response.data.highGame,
          highSeries: response.data.highSeries,
          lowGame: response.data.lowGame,
          lowSeries: response.data.lowSeries
        //  Assign values from request to state
        })
      })
      .catch(error => {
        if (error.response) {
          this.setState({status: "error", err: error.response.data});
        } else if (error.request) {
          this.setState({status: "error", err: "No Response"});
          console.log(error.request);
        } else {
          this.setState({status: "error", err: "Error with Request"});
          console.log('Error', error.message);
        }
      //  Catch errors
      });
  }

  render() {
    if(this.state.status === "OK") {
      return (
        <div className={'Player'}>
          {/*Contain in a div with class Player*/}
          <h1>{this.state.name}</h1>
          {/*Show player name*/}
          <table>
            {/*Create a table*/}
            <thead>
            <tr>
              <th rowSpan={2} colSpan={4}><h2>{this.state.name}</h2></th>
              <th colSpan={2}>Team</th>
              <th>Handicap</th>
              <th>High Game</th>
              <th>High Series</th>
              <th>Low Game</th>
              <th>Low Series</th>
              <th className={"invis"} />
            </tr>
            {/* Table headings, name, Team, Handicap, High Game... with an invis column at end hidden with css*/}
            <tr>
              <td colSpan={2}><span className={"back"}><Link to={"/team/" + this.state.team.id} >{this.state.team.name}</Link></span></td>
              {/*Show a link to the team, give it the class back so it can be used as a back button*/}
              <td>{Number.isInteger(this.state.handicap) ? this.state.handicap : "-"}</td>
              <td>{Number.isInteger(this.state.highGame) ? this.state.highGame : "-"}</td>
              <td>{Number.isInteger(this.state.highSeries) ? this.state.highSeries : "-"}</td>
              <td>{Number.isInteger(this.state.lowGame) ? this.state.lowGame : "-"}</td>
              <td>{Number.isInteger(this.state.lowSeries) ? this.state.lowSeries : "-"}</td>
              {/*Show player stats if exist, otherwise show - character*/}
              <td className={"invis"}><Delete id={this.state.id} type={'player'} name={this.state.name}/></td>
              {/*Show the delete button for a player*/}
            </tr>
            <tr>
              <th width="19%">Date</th>
              <th width="19%">Opposition</th>
              <th width="14%" colSpan={2}>Set 1</th>
              <th width="14%" colSpan={2}>Set 2</th>
              <th width="14%" colSpan={2}>Set 3</th>
              <th width="14%" colSpan={2}>Total</th>
              <th width="6%">Points</th>
              {/*Add recent games headers*/}
            </tr>
            </thead>
            {this.state.recentGames.map(game => (
              // For every game in recentGames, turn it into this
              <tbody key={game.id}>
              {/*tbody to put into table, key used so react doesn't complain*/}
                <tr>
                  <td><Link to={"/game/" + game.gameId}>{new Date(Date.parse(game.date)).toLocaleString('en-GB', { timeZone: 'UTC' })}</Link></td>
                  {/*Link to game page*/}
                  <td><Link to={"/team/" + game.opposition.id} id={game.opposition.id.toString()}>{game.opposition.name}</Link></td>
                  {/*Link to opposing team*/}
                  {game.scores.map(score => (
                    // For each score show
                    <React.Fragment key={score.id}>
                      {/*React fragment allows 2 top level things, usually have to be wrapped in a div, which isn't allowed in tables*/}
                      <td>{score.scratch}</td>
                      {/*Show scratch*/}
                      <td className={"handicapped"}>{score.handicapped}</td>
                      {/*Show handicap*/}
                    </React.Fragment>
                  ))}
                  <td>{game.scores.reduce((a, b) => a + b.score, 0)}</td>
                  {/*Show total score for the game*/}
                </tr>
              </tbody>
            ))}
          </table>
        </div>
      )
    } else if (this.state.status === "error") {
      // Show any errors
      return (
        <h2>{this.state.err}</h2>
      )
    } else {
      // If loading display loading wheel
      return <CircularProgress color={"primary"} />
    }
  }
}

export default Player;
// Export for easy importing
----

==== How does it look

.Sam Vimes Player table
image::dev-pictures/sam-vimes-table.png[playerTable, pdfwidth=100%]

==== Errors at this stage

===== Cannot be the child of parent
Cannot use a `div` inside a table as it is not a valid react child.
This can be swapped for `thead` or `tbody`.
Due to this error parts don't load properly and this error is thrown.

.Invalid Child
image::error-pictures/not-valid-child.png[invalidChild, pdfwidth=75%]

This is easily fixed, what's harder is that for scores, one cannot add non `td` to `tr`.
To fix that I updated react with `npm install --save react@16.0.0` and `npm install --save react-dom@16.0.0`.
I then used `<React.Fragment>`. This acts as if it doesn't exist to the page, but if means that it can export 2 td easily.


=== Generate and display Team stats

==== TeamRepositoryTest.java
What do we expect the queries to return. Makes it easier to develop the queries.

[source, java]
----
package com.saskcow.bowling.repository;

import ...

@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = {BowlingApplication.class})
@ActiveProfiles("test")
// Run with JUnit 4, it tests BowlingApplication, and it's a test
public class TeamRepositoryTest {

    @Autowired
    private TeamRepository teamRepository;
    @Autowired
    private GameRepository gameRepository;
    // Get team and game repositories
    private Team cableStreet;
    // Have team Cable Street Particulars available

    @Before
    public void populate() {
        // Before running the tests, populate the database with this

        Team cableStreet = new Team("Cable Street Particulars", null);
        cableStreet.addPlayer(new Player("Findthee Swing", cableStreet));
        cableStreet.addPlayer(new Player("Carcer", cableStreet));
        cableStreet.addPlayer(new Player("Todzy", cableStreet));
        this.cableStreet = teamRepository.save(cableStreet);
        // Save cableStreet with 3 players

        Team nightWatch = new Team("The Night Watch", null);
        nightWatch.addPlayer(new Player("Sam Vimes", nightWatch));
        nightWatch.addPlayer(new Player("Nobby Nobbs", nightWatch));
        nightWatch.addPlayer(new Player("Carrot Ironfoundersson", nightWatch));
        teamRepository.save(nightWatch);
        // Save nightWatch with 3 players

        Game game1 = new Game(null, null, "", new LinkedList<>(Arrays.asList(nightWatch, cableStreet)));
        Game game2 = new Game(null, null, "", new LinkedList<>(Arrays.asList(nightWatch, cableStreet)));
        // Create 2 games between the 2 teams

        cableStreet.addGame(game1);
        cableStreet.addGame(game2);
        nightWatch.addGame(game1);
        nightWatch.addGame(game2);
        // Add games to teams

        gameRepository.save(game1);
        gameRepository.save(game2);
        // Save games

        cableStreet.setPlayerGames(new LinkedList<>());
        nightWatch.setPlayerGames(new LinkedList<>());
        game1.setPlayerGames(new LinkedList<>());
        game2.setPlayerGames(new LinkedList<>());

        addPlayerGames(nightWatch, game1, game2);

        addPlayerGames(cableStreet, game1, game2);

        // Add playerGames for both teams using addPlayerGames function

        cableStreet.getPlayerGames().stream().filter(playerGame -> playerGame.getGame() == game1).forEach(playerGame -> {
            playerGame.addScore(new Score(playerGame, 50));
            playerGame.addScore(new Score(playerGame, 100));
            playerGame.addScore(new Score(playerGame, 150));
        });

        cableStreet.getPlayerGames().stream().filter(playerGame -> playerGame.getGame() == game2).forEach(playerGame -> {
            playerGame.addScore(new Score(playerGame, 100));
            playerGame.addScore(new Score(playerGame, 150));
            playerGame.addScore(new Score(playerGame, 200));
        });

        nightWatch.getPlayerGames().forEach(playerGame -> {
            playerGame.addScore(new Score(playerGame, 100));
            playerGame.addScore(new Score(playerGame, 150));
            playerGame.addScore(new Score(playerGame, 100));
        });

        // Add scores to games

        game1.completeGame();

        game2.completeGame();

        gameRepository.save(game1);
        gameRepository.save(game2);

        // Complete and save games, ready to get statistics

        this.cableStreet = teamRepository.save(cableStreet);
        // Save team and make it available in this

    }

    private void addPlayerGames(Team cableStreet, Game game1, Game game2) {
        cableStreet.getPlayers().forEach(player -> {
            // For every player in team
            player.addPlayerGame(new PlayerGame(player, cableStreet, game1));
            player.addPlayerGame(new PlayerGame(player, cableStreet, game2));
            // Add playerGame for each game
            game1.addPlayerGame(player.getPlayerGames().get(0));
            game2.addPlayerGame(player.getPlayerGames().get(1));
            // Add playerGame to each game
            cableStreet.addAllPlayerGame(player.getPlayerGames());
            // Add playerGames to the team
        });
    }

    // The Actual Tests!

    @Test
    public void highHandicapGame() {
        assertThat(teamRepository.highHandicapGame(this.cableStreet.getId())).isEqualTo(600);
        // Make sure high handicap game is 600 (highest team scratch in one set)
    }

    @Test
    public void highHandicapSeries() {
        assertThat(teamRepository.highHandicapSeries(this.cableStreet.getId())).isEqualTo(1350);
        // Make sure high handicap series is 1350 (highest team scratch in one full game)
    }

    @Test
    public void pinsFor() {
        assertThat(teamRepository.pinsFor(cableStreet.getId())).isEqualTo(2250);
        // Make sure Total pins scored is 2250
    }

    @Test
    public void pinsAgainst() {
        assertThat(teamRepository.pinsAgainst(cableStreet.getId())).isEqualTo(2100);
        // Check Total pins opposing team scored in games against team is 2100
    }

    @Test
    public void teamPoints() {
        assertThat(teamRepository.teamPoints(cableStreet.getId())).isEqualTo(8);
        // Check that the team player has got 8 points
    }

    @Test
    public void totalPoints() {
        assertThat(teamRepository.totalPoints(cableStreet.getId())).isEqualTo(32);
        // Check that the team has scored 32 points total
    }
}
----

==== TeamRepository.java
Now the queries happen
These were put in `@Query("$Query")` and then called by `Integer funcName(Long id);`

[source, sql]
----
-- highHandicapGame
SELECT MAX(s.scratch) FROM Team t JOIN t.playerGames pg JOIN pg.scores s WHERE t.id = :id AND s.total = FALSE AND pg.player IS NULL
-- Get the maximum scratch from team's playergame's scores which is of the teams id, is not a total, and doesn't have a player, (player is NULL)

-- highHandicapSeries
SELECT MAX(s.scratch) FROM Team t JOIN t.playerGames pg JOIN pg.scores s WHERE t.id = :id AND s.total = TRUE AND pg.player IS NULL
-- Get the maximum scratch from team's playergame's scores which is of the teams id, it is a total, and doesn't have a player, (player is NULL)

-- pinsFor
SELECT SUM(s.scratch) FROM Team t JOIN t.playerGames pg JOIN pg.scores s WHERE t.id = :id AND s.total = TRUE AND pg.player IS NULL
-- Get the total of the totals scratch scores (less work than totalling all 3 again) and don't have a player.

-- pinsAgainst
SELECT SUM(s.scratch) FROM Team t JOIN t.games g JOIN g.playerGames pg JOIN pg.scores s WHERE t.id = :id AND pg.team.id <> :id AND pg.player IS NULL AND s.total = TRUE
-- For every game the team has get the playerGames, for every playerGame where the team is NOT the team given, add up the scratch scores of those with no player and are totals

-- teamPoints
SELECT SUM(s.score) FROM Team t JOIN t.playerGames pg JOIN pg.scores s WHERE t.id = :id AND pg.player IS NULL
-- Same as pinsFor except adds score, not scratch and adds totals as well for

-- totalPoints
SELECT SUM(s.score) FROM Team t JOIN t.playerGames pg JOIN pg.scores s WHERE t.id = :id
-- Get the total score of every score of every playergame, ignoring if real player or not or total or not.
----

These function very similarly to the player ones, but get team statistics.

==== TeamView.java
Getting more data.

[source, java]
----
private Integer pinsFor;
private Integer pinsAgainst;
private Integer highHandicapGame;
private Integer highHandicapSeries;
private Integer teamPoints;
private Integer totalPoints;
private Integer numGames;
// Stats asdded to things it has

// In constructor
this.numGames = team.getGames() != null ? (int) team.getGames().stream().filter(a -> a.getPlayerGames().size() == 8).count() : 0;
// Count the number of games which are completed ans save it to numGames as int
----

==== TeamController.java
Needs to populate the data.

[source, java]
----
TeamView teamView = new TeamView(team);
teamView.setPinsFor(repo.pinsFor(team.getId()));
teamView.setPinsAgainst(repo.pinsAgainst(team.getId()));
teamView.setHighHandicapGame(repo.highHandicapGame(team.getId()));
teamView.setHighHandicapSeries(repo.highHandicapSeries(team.getId()));
teamView.setTeamPoints(repo.teamPoints(team.getId()));
teamView.setTotalPoints(repo.totalPoints(team.getId()));
----

Done very similarly to PlayerController

==== Team.js
Players have, little information. Why do they need a page of their own? They don't. So now the Team will have all the
player data as well.

[source, jsx]
----
import ...

class Team extends React.Component {

  constructor(props) {
    super();
    this.state = {status: "Loading"};
    // Set default state
    this.getTeam = this.getTeam.bind(this);
    this.getNewTeam = this.getNewTeam.bind(this);
    // Bind this to things
    this.getTeam(props.match.params.id);
  //   Get the team details with id from path
  }

  getTeam(id) {
    axios.get('/api/team/' + id)
      .then(response => {
        this.setState({
          status: "OK",
          id: id,
          name: response.data.name,
          league: response.data.league,
          players: response.data.players,
          games: response.data.games,
          numGames: response.data.numGames,
          pinsFor: response.data.pinsFor,
          pinsAgainst: response.data.pinsAgainst,
          highHandicapGame: response.data.highHandicapGame,
          highHandicapSeries: response.data.highHandicapSeries,
          teamPoints: response.data.teamPoints,
          totalPoints: response.data.totalPoints
        //  Put response into state
        })
      })
      .catch(error => {
        console.log(error)
      //  Log errors
      })
  };


  getNewTeam(event) {
    event.preventDefault();
    console.log(event.currentTarget);
    this.getTeam(event.currentTarget.id);
    // getTeam, for the team given in the event
  }

  // For getting opposition team

  render() {
    if(this.state.status === "OK") {
      return (
        <div className={'Team'}>

          <h1>{this.state.name}</h1>
          <Link className={"back"} to={"/league/" + this.state.league.id}><Button variant={"raised"}>{this.state.league.name}</Button></Link>
          {/*Link back and have title of page*/}

          <table className={"Stats"}>
            <thead>
            <tr>
              <th>Games</th>
              <th>Pins For</th>
              <th>Pins Against</th>
              <th>HHG</th>
              <th>HHS</th>
              <th>Team Pts</th>
              <th>Total Pts</th>
            </tr>
            {/*Table headings for team details*/}
            </thead>
            <tbody>
            <tr>
              <td>{this.state.numGames}</td>
              <td>{this.state.pinsFor}</td>
              <td>{this.state.pinsAgainst}</td>
              <td>{this.state.highHandicapGame}</td>
              <td>{this.state.highHandicapSeries}</td>
              <td>{this.state.teamPoints}</td>
              <td>{this.state.totalPoints}</td>
            </tr>
            {/*Values of the information*/}
            </tbody>
          </table>

          <h3>Players</h3>
          {/*Players subtitle*/}

          <ul className={"Players"}>
            {this.state.players.map(player => (
              // For every player
              <ExpansionPanel key={player.id} className={'player-' + player.name.replace(/\s+/g, '-').toLowerCase()}>
                {/*Create an expansion panel to hide the table in, make it look cleaner*/}
                <ExpansionPanelSummary expandIcon={<KeyboardArrowDown />}>
                  <Typography className={"Player"}>{player.name}</Typography>
                  {/*Show player name and down icon when hidden*/}
                </ExpansionPanelSummary>
                <ExpansionPanelDetails>
                  <Player refresh={this.getNewTeam} id={player.id}/>
                  {/*Create player of playerId*/}
                </ExpansionPanelDetails>
              </ExpansionPanel>
            ))}
          </ul>
          <Link to={{pathname: ("/team/" + this.state.id + '/add-player'), state: {teamName: this.state.name}}}><Button className={"addPlayer"} variant={"raised"} color={"primary"}>Add A Player</Button></Link>
          {/*Add a player button*/}
          <h3>Games</h3>
          <ul className={"Games"}>
            {/*Create a list of games like League has*/}
            {this.state.games.map(game => (
              <GameSummary key={game.id} id={game.id} winner={game.winner} time={game.time} teams={game.teams}>{game.venue}</GameSummary>
            //   Create a list of GameSumamry
            )).sort((a, b) => {
              // Sort them before displaying
              if(Number.isInteger(a.props.winner) && !Number.isInteger(b.props.winner)) {
                return 1;
              //  If one of the games is finished, move it to the bottom
              } else if(!Number.isInteger(a.props.winner) && Number.isInteger(b.props.winner)) {
                return -1;
                //  If one of the games is finished, move it to the bottom
              } else {
                const aTime = Date.parse(a.props.time);
                const bTime = Date.parse(b.props.time);
                return aTime - bTime;
                // If neither complete, or both complete, sort them by time, recent games top
              }}
            )}
          </ul>
        </div>
      )
    } else if (this.state.status === "error") {
      return (
        <h2>{this.state.err}</h2>
      //  Show errors
      )
    } else {
      return <CircularProgress color={"primary"} />
    //  If not loaded show a loading wheel
    }
  }
}

export default Team;
----

==== Player.js
Small modifications so it fits in the table.

[source, jsx]
----
this.getPlayer(props.id);
// Gets id from Team, doesn't need one from route anymore

onClick={this.props.refresh}
// Added to opposition link, this calls the refresh which takes the id and displays the other team
----
That was it.

==== App.js
Players no longer have their own page, their route has been removed.

==== Errors at this stage

===== TeamRepositoryTesting incomplete data
When writing the test I forgot to add playerGames to a game.
This led to pinsAgainst being far lower than expected, `0` not `2100`.

===== Not getting opposition team
Since Team object to Team object now instead of Player to Team, react-router isn't refreshing the page.
This meant that clicking the opponent team, changed the url, and that was it.
Thus I made it get the other teams data and display that.
`onClick={this.props.refresh}` was added to the button so it would call function given in props by team.
Therefore it can call the `getNewTeam` function and change the team to the opposing team.

=== League shows a table of all the Teams stats
League wants this information too, shouldn't have to find each team individually to compare.

==== LeagueView.java
Now has `TeamViewLeague` not `TeamViewSummary` objects.

==== TeamViewLeague.java
A `TeamViewSummary` but with

[source, java]
----
private Integer pinsFor;
private Integer pinsAgainst;
private Integer highHandicapGame;
private Integer highHandicapSeries;
private Integer teamPoints;
private Integer totalPoints;
private Integer numGames;
----

these stats added.

==== LeagueController.java
Needs a sorted list by total points where points can be null

[source, java]
----
leagueView.getTeams().forEach(team -> {
    // For every team
    Long x = team.getId();
    // Get the id
    team.setPinsFor(teamRepository.pinsFor(x));
    team.setPinsAgainst(teamRepository.pinsAgainst(x));
    team.setHighHandicapGame(teamRepository.highHandicapGame(x));
    team.setHighHandicapSeries(teamRepository.highHandicapSeries(x));
    team.setTeamPoints(teamRepository.teamPoints(x));
    team.setTotalPoints(teamRepository.totalPoints(x));
    // Set stats on the TeamViewLeague
});

leagueView.getTeams().sort(Comparator.comparing(team -> team.getTotalPoints() != null ? -team.getTotalPoints() : 0));
// Get the teams and sort them so that if points are null, it goes bottom, and otherwise compares team by highest points.
----

==== League.js
The hard bit, now how should this be displayed. It seems logical to use a table again as it is tabular data.
So it will have a table with a row for each team. main return in render now returns this.

[source, jsx]
----
<div className={'League'}>
  {/*Contain in League div*/}

  <h1>{this.state.name}</h1>
  <Link className={"back"} to={"/league/"}><Button variant={"raised"}>Back to Leagues</Button></Link>

  <h3>Team Standings</h3>
  <table className={"Teams"}>
    {/*Create Teams table*/}
    <thead>
    <tr>
      <th width="5%">Position</th>
      <th width="20%">Team</th>
      <th width="10%">Games</th>
      <th width="10%">Pins For</th>
      <th width="10%">Pins Against</th>
      <th width="10%">HHG</th>
      <th width="10%">HHS</th>
      <th width="10%">Team Pts</th>
      <th width="10%">Total Pts</th>
      <th width="5%" className={"invis"} />
    </tr>
    </thead>
    {/*Add table headings, with invis far right for delete button*/}
    {this.state.teams.map((team) => (
      // For every team, make a team summary with the team
      <TeamSummary
        key={team.id}
        id={team.id}
        position={index + 1}
        numGames={team.numGames !== null ? team.numGames : "-"}
        pinsFor={team.pinsFor !== null ? team.pinsFor : "-"}
        pinsAgainst={team.pinsAgainst !== null ? team.pinsAgainst : "-"}
        highHandicapGame={team.highHandicapGame !== null ? team.highHandicapGame : "-"}
        highHandicapSeries={team.highHandicapSeries !== null ? team.highHandicapSeries : "-"}
        teamPoints={team.teamPoints !== null ? team.teamPoints : "-"}
        totalPoints={team.totalPoints !== null ? team.totalPoints : "-"}
      >
        {team.name}
      </TeamSummary>
    ))}
  </table>
  <Link to={{pathname: ("/league/" + this.state.id + '/add-team'), state: {leagueName: this.state.name}}}><Button className={"addTeam"} variant={"raised"} color={"primary"}>Add A Team</Button></Link>
  {/*Link to add a new team*/}

  <h3>Games</h3>
  {/*Games section*/}
  <ul className={"Games"}>
    {this.state.games.map(game => (
      <GameSummary key={game.id} id={game.id} winner={game.winner} time={game.time} teams={game.teams}>{game.venue}</GameSummary>
    //  Create a GameSummary for every game
    )).sort((a, b) => {
      if(Number.isInteger(a.props.winner) && !Number.isInteger(b.props.winner)) {
        return 1;
      } else if(!Number.isInteger(a.props.winner) && Number.isInteger(b.props.winner)) {
        return -1;
      } else {
        const aTime = Date.parse(a.props.time);
        const bTime = Date.parse(b.props.time);
        return aTime - bTime;
      }}
    //  Sort so incomplete games first, earliest games first
    )}
  </ul>
  {/*No change*/}
  <Link to={"/league/" + this.state.id + '/add-game'}><Button className={"addGame"} variant={"raised"} color={"primary"}>Add A Game</Button></Link>
  {/*Link to add a game page*/}

</div>
----

==== TeamSummary.js
Teams are now a bit more detailed, and now a table, so this needs updating.

[source, jsx]
----
import ...

class TeamSummary extends React.Component {
  // Create a Component
  render() {
    return (
      // When displayed to screen show this
      <tbody>
      {/*Wrapped in tbody so it's a valid child*/}
      <tr className={this.props.children.replace(/\s+/g, '-').toLowerCase()}>
        {/*Create a row in the table*/}
        <td>{this.props.position}</td>
        <td><Link to={'/team/' + this.props.id}>{this.props.children}</Link></td>
        <td>{this.props.numGames}</td>
        <td>{this.props.pinsFor}</td>
        <td>{this.props.pinsAgainst}</td>
        <td>{this.props.highHandicapGame}</td>
        <td>{this.props.highHandicapSeries}</td>
        <td>{this.props.teamPoints}</td>
        <td>{this.props.totalPoints}</td>
        <td className={"invis"}><Delete id={this.props.id} type={'team'} name={this.props.children}/></td>
        {/*Add all the stats in columns and add a delete button*/}
      </tr>
      </tbody>
    )
  }
}
// Export for easier imports
export default TeamSummary;
----

And now it's displayed.

==== Errors at this stage

===== Sorting in reverse
In java a Comparator comparing does it in ascending order. To fix this `-` was added so it sorted the other order as the highest
values were now the lowest.

===== Many nulls in output
This wasn't crashing anything, but it was not ideal modifying `TeamViewSummary` to have all the details as many places
wouldn't need the data, so it was null. Thus `TeamViewLeague` was created.

=== Nightwatch rewrite
Before it is finished, it needs a more thorough test. The easiest way to do this was not to rewrite the entire thing.
But it was done.

The new tests had to have less redundancy than the old tests (Therefore shorter), and work with the newer version.
It also had to name the screenshots to give a more obvious idea of what was done to anyone reading the writeup.
It also needed to have less unnecessary pauses as it takes too long to run.

It also, most importantly, had to have nicer names for Leagues, Teams and Players. So a test name scheme was created.
It was then only used for these.

==== 1. Creating Teams and Players.js
This creates everything a game needs.

[source, js]
----
const dir = './reports/screenshots/1. Creating Teams and Players/';
// Set screenshot directory

module.exports = {
  // Export TestCases
  'Add some Leagues' : (browser) => {
    // Create TestCase Add some Leagues, nightwatch will give it a browser when called
    browser
      .url('http://user:saskcow@localhost:8080/league')
      // Give auth if required
      .waitForElementVisible('body', 2000)
      .waitForElementVisible('.Leagues', 2000)
      // Wait for page to load for 2 seconds, then a further 2 for leagues to be visible
      .saveScreenshot(dir + '01 - Before any data entry.png')
      // Save a screenshot of the empty program
      .click('button[class~=add]')
      // Click add
      .waitForElementVisible('input[id=LeagueName]', 2000)
      .saveScreenshot(dir + '02 - Click add a League button.png')
      // Screenshot the add League page
      .setValue('input[id=LeagueName]', 'City Watch')
      .saveScreenshot(dir + '03 - Add the name of the League.png')
      // Set input to have City Watch
      .click('button[class~=submitForm]')
      .waitForElementVisible('.Leagues', 2000)
      .assert.containsText('.Leagues', 'City Watch')
      .saveScreenshot(dir + '04 - Submit the form to add the league.png')
      // Click submit, wait for leagues to load, check league added, save a screenshot

      // Do it all again, but with less screenshots, and with The Disc instead
      .click('button[class~=add]')
      .waitForElementVisible('input[id=LeagueName]', 2000)
      .setValue('input[id=LeagueName]', 'The Disc')
      .click('button[class~=submitForm]')
      .waitForElementVisible('.Leagues', 2000)
      .assert.containsText('.Leagues', 'The Disc')
      .saveScreenshot(dir + '05 - Add another League.png');
  },

  'Add some Teams to the City Watch' : (browser) => {
    // Create another TestCase
    browser
      .click('li[class~=city-watch]>a')
      .waitForElementVisible('.League', 2000)
      .assert.containsText('h2', 'City Watch')
      .saveScreenshot(dir + '06 - Click on the League to view the League page.png')
      // Click the link to city watch page, wait for it to load, check header and save a screenshot

      .click('button[class~=addTeam]')
      .waitForElementVisible('input[id=TeamName]', 2000)
      .saveScreenshot(dir + '07 - Click on the add a Team button, to add a Team.png')
      // Click add team, wait for page to load, and save a screenshot
      .setValue('input[id=TeamName]', 'The Night Watch')
      .saveScreenshot(dir + '08 - Enter the Team name.png')
      // Enter the teams name, and save a screenshot
      .click('button[class~=submitForm]')
      .waitForElementVisible('.League', 2000)
      .assert.containsText('.Teams', 'The Night Watch')
      .saveScreenshot(dir + '09 - One Team added to the League.png')
      // Wait till League page loaded and check team added, then of course, save a screenshot

      .click('button[class~=addTeam]')
      .waitForElementVisible('input[id=TeamName]', 2000)
      .setValue('input[id=TeamName]', 'The Day Watch')
      .click('button[class~=submitForm]')
      .waitForElementVisible('.League', 2000)
      .assert.containsText('.Teams', 'The Day Watch')
      // Add another

      .click('button[class~=addTeam]')
      .waitForElementVisible('input[id=TeamName]', 2000)
      .setValue('input[id=TeamName]', 'Cable Street Particulars')
      .click('button[class~=submitForm]')
      .waitForElementVisible('.League', 2000)
      .assert.containsText('.Teams', 'Cable Street Particulars')
      // And another

      .click('button[class~=addTeam]')
      .waitForElementVisible('input[id=TeamName]', 2000)
      .setValue('input[id=TeamName]', 'Pseudopolis Yard')
      .click('button[class~=submitForm]')
      .waitForElementVisible('.League', 2000)
      .assert.containsText('.Teams', 'Pseudopolis Yard')
      // One more

      .assert.containsText('.Teams', 'The Night Watch')
      .assert.containsText('.Teams', 'The Day Watch')
      .assert.containsText('.Teams', 'Cable Street Particulars')
      .assert.containsText('.Teams', 'Pseudopolis Yard')
      // Check they all still exist

      .saveScreenshot(dir + '10 - Added all the Teams now, can\'t play with one team.png');
      // Save another screenshot
  },

  'Add some Players to these Teams' : (browser) => {
    // Another TestCase
    browser
      .click('tr[class~=the-night-watch] a')
      .waitForElementVisible('.Team', 2000)
      .saveScreenshot(dir + '11 - Click a team to go to the team page.png')
      // Click on The Night Watch team

      .click('button[class~=addPlayer]')
      .saveScreenshot(dir + '12 - Click add a Player to go to the add a player page.png')
      // Click add player to go to the page, save a screenshot
      .waitForElementVisible('input[id=PlayerName]', 2000)
      .setValue('input[id=PlayerName]', 'Sam Vimes')
      .saveScreenshot(dir + '13 - Insert desired Player name into the input.png')
      // Input name, save screenshot
      .click('button[class~=submitForm')
      .waitForElementVisible('.Team', 2000)
      .assert.containsText('.Players', 'Sam Vimes')
      .saveScreenshot(dir + '14 - Submit the form to finish adding player.png')
      // Save the screenshot of adding a player
      .click('.back');
      // Click back

    const playersTeams = {the_night_watch: ["Carrot Ironfoundersson", "Nobby Nobbs", "Fred Colon"],
      the_day_watch: ["Mayonnaise Quirke", "Skully Muldoon", "Doxie"],
      cable_street_particulars: ["Findthee Swing", "Carcer", "Gerald Leastways, a.k.a. Ferret", "Todzy"],
      pseudopolis_yard: ["Igor", "Mad Arthur", "Reginald Shoe", "Angua Von Überwald"]
    };
    // Create a dictionary of teams and the players hich need adding

    const keys = Object.keys(playersTeams);
    // Save playerTeams keys to an array
    for(let i = 0; i < keys.length; i++) {
      // For every team
      const team = keys[i];
      // The team = the name of the team
      browser
        .waitForElementVisible('.League', 2000)
        .click('tr[class~=' + team.replace(/(_)+/g, '-') + ']>td>a')
        .waitForElementVisible('.Team', 2000);
        // Click on the team in the list of teams and wait for it to load
      playersTeams[team].forEach(player => {
        // For every player on the team
        browser
          .click('button[class~=addPlayer]')
          // Click on add a player
          .waitForElementVisible('input[id=PlayerName]', 2000)
          .setValue('input[id=PlayerName', player)
          // Wait for it to load and set playername
          .click('button[class~=submitForm]')
          .waitForElementVisible('.Team', 2000)
          .assert.containsText('.Players', player)
          // Submit and check it was added
      });
      browser
        // When done, save a screenshot of the completed team
        .saveScreenshot(dir + '15 - Added the rest of the Players to ' + team + '.png')
        .click('.back')
        .waitForElementVisible('.League', 2000);
        // Go back to league page
    }
  },

  'Look at the Players' : (browser) => {
  browser
    .click('tr[class~=the-night-watch]>td>a')
    // Click on the night watch
    .waitForElementVisible('.Team', 2000)
    .click('div[class~=player-sam-vimes]>div>div')
    // Click on the Sam Vimes dropdown
    .waitForElementVisible('.Player', 2000)
    .pause(500)
    // Wait for it to be fully extended
    .saveScreenshot(dir + '16 - Sam vimes Profile.png')
    .end();
    // Save a screenshot and close the browser
  }

};
----

==== 2. Creating a Game and Adding Players.js
Create the game and add players to it

[source, js]
----
const dir = './reports/screenshots/2. Creating a Game and Adding Players/';
// Set image directory

module.exports = {
  'Add some Games' : (browser) => {
    browser
      .url('http://user:saskcow@localhost:8080/league')
      // Give auth if required
      .waitForElementVisible('body', 2000)
      .waitForElementVisible('.Leagues', 2000)
      .click('li[class~=city-watch]>a')
      .waitForElementVisible('.League', 2000)
      .saveScreenshot(dir + '01 - The League page, with all the teams.png')
      // Navigate to the league page and save a screenshot
      .click('button[class~=addGame]')
      .waitForElementVisible('.theGameForm', 2000)
      .assert.containsText('h1', 'City Watch')
      .saveScreenshot(dir + '02 - Click add a Game, to go to the add game form.png')
      // Click the add game button and wait till loaded, then save a screenshot

      .setValue('input[id=Venue]', 'Dolly Sisters')
      .setValue('input[id=datetime-local]', "14-03-2020")
      // Set venue to Dolly Sisters, set time to the 14th of march 2020

      .click("div[class~=team1] div[role=button]")
      .waitForElementVisible('div[id=menu-team1] > div > ul > li[name=team1-the-night-watch]', 2000)
      // Click on team 1 dropdown and wait for it do have extended
      .saveScreenshot(dir + "03 - Fill in the Teams with the dropdown.png")
      .click("li[name=team1-the-night-watch]")
      // Click The Night Watch in dropdown

      .pause(300)
      // Wait for it to close

      .click("div[class~=team2] div[role=button]")
      .waitForElementVisible('div[id=menu-team2] > div > ul > li[name=team2-pseudopolis-yard]', 2000)
      .click("li[name=team2-pseudopolis-yard]")
      .pause(300)
      // Set second team to Pseudopolis Yard

      .saveScreenshot(dir + '04 - Finish completing form.png')
      // Save a screenshot of the complete form
      .click('.theGameForm button[type=submit]')
      .waitForElementVisible('.League', 2000)
      .assert.containsText('.Games', 'Dolly Sisters')
      .saveScreenshot(dir + '05 - Added the Game.png')
      // Submit, check everything exists, and save a screenshot


      .click('button[class~=addGame]')
      .waitForElementVisible('.theGameForm', 2000)
      .assert.containsText('h1', 'City Watch')
      .setValue('input[id=Venue]', 'Treacle Mine Road')
      .setValue('input[id=datetime-local]', "14-03-2020")
      .click("div[class~=team1] div[role=button]")
      .waitForElementVisible('div[id=menu-team1] > div > ul > li[name=team1-cable-street-particulars]', 2000)
      .click("li[name=team1-cable-street-particulars]")
      .pause(300)
      .click("div[class~=team2] div[role=button]")
      .waitForElementVisible('div[id=menu-team2] > div > ul > li[name=team2-the-night-watch]', 2000)
      .click("li[name=team2-the-night-watch]")
      .pause(300)
      .click('.theGameForm button[type=submit]')
      .waitForElementVisible('.League', 2000)
      .assert.containsText('.Games', 'Treacle Mine Road')
      // Add a second game between Cable Street Particulars and The Night Watch at Treacle Mine Road

      .saveScreenshot(dir + "06 - Add a second Game.png")
  },

  'Fill in Players for The Night Watch' : (browser) => {
    browser
      .waitForElementVisible('.League', 2000)
      .click('li[class~=the-night-watch-vs-pseudopolis-yard-at-dolly-sisters]>p>a')
      .waitForElementVisible('.Game', 2000)
      .saveScreenshot(dir + '07 - Game with no players.png')
      // Click on the game to see the add players dropdown
      .click('div[class~=add-to-the-night-watch]>div>div')
      .waitForElementVisible('.thePlayersForm', 2000)
      // Click on the add players to Night Watch and wait for form to load

      .click("div[class~=player1] div[role=button]")
      // Click on player dropdown 1
      .waitForElementVisible('div[id=menu-player1] > div > ul > li[name=player1-sam-vimes]', 2000)
      .saveScreenshot(dir + "08 - Fill in the Players with the dropdown.png")
      // Wait for it to load and save a screenshot
      .click("li[name=player1-sam-vimes]")
      .pause(300)
      // Click Sam Vimes and wait for it to close

      .click("div[class~=player2] div[role=button]")
      .waitForElementVisible('div[id=menu-player2] > div > ul > li[name=player2-nobby-nobbs]', 2000)
      .click("li[name=player2-nobby-nobbs]")
      .pause(300)

      .click("div[class~=player3] div[role=button]")
      .waitForElementVisible('div[id=menu-player3] > div > ul > li[name=player3-nobby-nobbs]', 2000)
      .click("li[name=player3-nobby-nobbs]")
      .pause(300)

      // Set 2 and 3 to Nobby Nobbs

      .click('button[class~=submitForm]')
      .waitForElementVisible('.errorMessage', 2000)
      .saveScreenshot(dir + '09 - Rejects duplicates or empty.png')
      // Check it displays an error message and screenshot it

      .click("div[class~=player3] div[role=button]")
      .waitForElementVisible('div[id=menu-player3] > div > ul > li[name=player3-carrot-ironfoundersson]', 2000)
      .click("li[name=player3-carrot-ironfoundersson]")
      .pause(300)
      // Change 3 to Carrot instead

      .saveScreenshot(dir + '10 - Fill in form without empty or duplicates values.png')
      .click('.thePlayersForm > button[class~=submitForm]')
      .waitForElementVisible('table[id=the-night-watch]', 2000)
      // Submit the form and wait for team table in game to load

      .assert.containsText('#the-night-watch', 'Sam Vimes')
      .assert.containsText('#the-night-watch', 'Nobby Nobbs')
      .assert.containsText('#the-night-watch', 'Carrot Ironfoundersson')

      .saveScreenshot(dir + '11 - Submit form to generate Game table.png');
      // Check all 3 players in table and save screenshot of it

  },

  'Fill in Players for Pseudopolis Yard' : (browser) => {
    browser
      .click('div[class~=add-to-pseudopolis-yard]>div>div')
      .waitForElementVisible('.thePlayersForm', 2000)

      .click("div[class~=player1] div[role=button]")
      .waitForElementVisible('div[id=menu-player1] > div > ul > li[name=player1-igor]', 2000)
      .click("li[name=player1-igor]")
      .pause(300)

      .click("div[class~=player2] div[role=button]")
      .waitForElementVisible('div[id=menu-player2] > div > ul > li[name=player2-reginald-shoe]', 2000)
      .click("li[name=player2-reginald-shoe]")
      .pause(300)

      .click("div[class~=player3] div[role=button]")
      .waitForElementVisible('div[id=menu-player3] > div > ul > li[name=player3-angua-von-überwald]', 2000)
      .click("li[name=player3-angua-von-überwald]")
      .pause(300)

      .saveScreenshot(dir + '12 - Fill in form for Pseudopolis Yard.png')
      .click('button[class~=submitForm]')
      .waitForElementVisible('table[id=pseudopolis-yard]', 2000)

      .assert.containsText('#pseudopolis-yard', 'Igor')
      .assert.containsText('#pseudopolis-yard', 'Reginald Shoe')
      .assert.containsText('#pseudopolis-yard', 'Angua Von Überwald')

      // Add players in the same way to the second team

      .saveScreenshot(dir + '13 - Game with all players, ready to play.png')
      .end();
      // Save a screenshot and close browser

  }

};
----

==== 3. Adding Scores and Scoring the Game.js
This just adds scores to the game and completes the game, then goes through to league to show changes and check game is complete.

[source, js]
----
const dir = './reports/screenshots/3. Adding Scores and Scoring the Game/';

module.exports = {
  // Export TestCases
  'Get to the Game' : (browser) => {
    // Create testCase Get to the Game
    browser
      .url('http://user:saskcow@localhost:8080/league')
      // Give auth if required
      .waitForElementVisible('body', 2000)
      .waitForElementVisible('.Leagues', 2000)
      .click('li[class~=city-watch]>a')
      .waitForElementVisible('.League', 2000)
      .click('li[class~=the-night-watch-vs-pseudopolis-yard-at-dolly-sisters]>p>a')
      .waitForElementVisible('.Game', 2000)
      .saveScreenshot(dir + "01 - The game.png")
      // Click buttons till arrived at the game page
  },

  'Add Scores to the Game' : (browser) => {
    browser
      .setValue('#sam-vimes-scratch', 120)
      .saveScreenshot(dir + '02 - Just enter a scratch score and the handicap will be added from the backend.png')
      // Enter scratch score, adjusted for handicap (0)
      .click('#sam-vimes-submit')
      // Submit score
      .waitForElementVisible('#sam-vimes-scratch', 2000)
      .setValue('#sam-vimes-scratch', 120)
      .setValue('#sam-vimes-handicap', 20)
      .click('#sam-vimes-checkHandicap')
      // Override handicap as 20
      .waitForElementVisible('#sam-vimes-scratch', 2000)
      .saveScreenshot(dir + "03 - Can also enter a value into handicap and check box to overrule the existing value.png")
      .click('#sam-vimes-submit')
      .waitForElementVisible('#sam-vimes-scratch', 2000)
      .setValue('#sam-vimes-scratch', 350)
      .click('#sam-vimes-submit')
      .waitForElementVisible('.errorMessage', 2000)
      // Enter an impossible score, get rejected
      .saveScreenshot(dir + "04 - Rejects impossible scores.png")
      .clearValue('#sam-vimes-scratch')
      .setValue('#sam-vimes-scratch', 300)
      .click('#sam-vimes-submit')
      // Enter a valid score and submit it
      .waitForElementVisible('.Game', 2000)
      .waitForElementVisible('#sam-vimes-full', 2000)
      .saveScreenshot(dir + "05 - A complete row of Scores.png");
      // Check full row and save screenshot

    const players = ["Carrot Ironfoundersson", "Nobby Nobbs", "Igor", "Reginald Shoe", "Angua Von Überwald"].map(player => player.replace(/\s+/g, '-').toLowerCase());
    players.forEach(player => {
      // For every player in the game
      for(let i = 0; i < 3; i++) {
        // Do this 3 times
        browser
          .setValue('#' + player + '-scratch', Math.floor(Math.random()*300))
          // Add a random score 0-300
          .click('#' + player + '-submit')
          // Submit score
          .waitForElementVisible('.Game', 2000)
      }
      browser.waitForElementVisible('#' + player + '-full', 2000)
      // Check each player has all scores
    });

    browser
      .waitForElementVisible('#scoreGame', 2000)
      // Check scoreGame shown, should appear when all scores are entered
      .saveScreenshot(dir + '06 - All scores added.png')
  },

  'Finish the Game' : browser => {
    browser
      .waitForElementVisible('#scoreGame', 2000)
      .click('#scoreGame')
      .waitForElementVisible('.winner, .loser', 2000)
      // Score the game and expect a winner or a loser to appear, both should
      .saveScreenshot(dir + '07 - All scores calculated, winner and loser selected.png')
      .click('.back')
      .waitForElementVisible('.League', 2000)
      .assert.containsText('.Games', 'won!')
      // On league page check that the game is marked as complete
      .saveScreenshot(dir + '08 - Game sorted to bottom and game winner shown.png')
      .end();
      // Close browser
  }
};
----

==== 4. Cleaning Up
Just deletes what it created so it can be run multiple times.

[source, js]
----
const dir = './reports/screenshots/4. Cleaning Up/';

module.exports = {
  'Remove the Day Watch' : browser => {
    browser
      .url('http://user:saskcow@localhost:8080/league')
      // Give auth if required
      .waitForElementVisible('body', 2000)
      .waitForElementVisible('.Leagues', 2000)
      .click('li[class~=city-watch]>a')
      .waitForElementVisible('.League', 2000)
      .saveScreenshot(dir + '01 - The Day Watch no longer want to participate.png')
      // Navigate to league page
      .click('button[name=delete-the-day-watch]')
      .waitForElementNotPresent('tr[class~=the-day-watch]', 2000)
      .saveScreenshot(dir + '02 - Team Deleted.png')
      // Delete day watch
  },

  'League Over' : browser => {
    browser
      .click('.back')
      .waitForElementVisible('.Leagues', 2000)
      .saveScreenshot(dir + '03 - Leagues both over.png')
      .click('button[name=delete-city-watch]')
      .waitForElementNotPresent('li[class~=city-watch]', 2000)
      .click('button[name=delete-the-disc]')
      .waitForElementNotPresent('li[class~=the-disc]', 2000)
      .saveScreenshot(dir + '04 - Leagues deleted.png')
      // Click delete on both leagues, check both are gone
      .end();
      // Close browser
  }
};
----

==== Errors at this stage

===== Test ordering
Tests have to be ran in the correct order or it will expect a league to exist, and it may not. To solve this the tests
all start with a number so they run in the correct order.

===== Wait a second
A second was too long, but occasionally with a 250ms pause it would take too long. Now it waits 300ms for dialogues to close
to reduce errors occurring.

===== Incorrect naming
Tests and the image folder have to have the same name to be compatible with the testtoadoc program I wrote to add it to the writeup.
This is also case sensitive and a capital letter in the test caused the testtoadoc program to crash.

===== Picture numbering
Pictures are added in number order in testtoadoc, there is no other good way I found to order them correctly.
Therefore when no numbers were in the screenshot names, the screenshots were in random order.

include::test/5 - has all data front and back.adoc[]

=== Polish
No backend changed, just making the front end nicer to use and more consistent.

==== Headers
I really liked how games looked with the header at the top. So I used this in every other screen.

[source, jsx]
----
(<header className="App-header">
  <Link className={"back"} to={"/object/"}><Button variant={"raised"}>Back to Previous</Button></Link>
  <h1 className="App-title">{this.state.name}</h1>
</header>)
// Added to most components to replace existing h1/h2 title and back buttons
----

Added to all Components with routes. On add screens the back button will name what it links back to as well.
For example in `AddTeam.js`

[source, js]
----
if (this.state.leagueName === null || this.state.leagueName === undefined) {
  this.getLeague(this.state.leagueId)
}
// Check if league name known, if not get it
// Then will use a placeholder if leagueName is null or undefined

getLeague(id) {
  axios.get('/api/league/' + id)
    .then(response => {
      this.setState({leagueName: response.data.name})
    })
    .catch(error => {
      console.log(error)
    })
};

// Gets the name of the league to replace the placeholder in title and back button
----

==== Header CSS
Currently it's a back button then an h1. Nothing special.
This is where some css I found and modified a bit helps.

[source, css]
----
.App-header {
    background-color: #222;
    height: 75px;
    padding: 20px;
    color: white;
}

.Game .App-header {
    background-color: #222;
    height: 150px;
    padding: 20px;
    color: white;
}

.App-title {
    font-size: 3em;
    width: 80%;
    display: inline-block;
}

.App-title-game {
    font-size: 1.5em;
    width: 90%;
    display: inline-block;
}

.back {
    float: right;
}
----

A new set of css was added for game as the header needed to be taller to facilitate the date.
The titles are set to a width of 80% so the floating right back button is inline with the title. This makes it Always
in the top right of the page for easier navigation.

==== Back Buttons
Back buttons should be consistent in placement. It makes the website easier to navigate. So on every page part of the header.

include::test/6 - Polished.adoc[]

== Evaluation

=== My thoughts
I don't think the program is complete, but I think it offers a nicer interface to use for the league. However due to a
lack of some features it is not currently fit to be a full replacement of the current system.

=== Client thoughts
The client agrees that some crucial features are missing before it could be implemented as a replacement, however the
features present are far easier to use than uploading all the HTML every time anything changes. Thus the client is
interested in adding blind scores and similar features so it can replace the existing system.

=== Continued development
The project is up on github with an open source license. Anyone can add issues of required features and anyone can
create a fork, modify it and send a pull request to merge the code on bowling with their branch.

//== Test Formatter
//I wrote a test formatter in python to format the xml into asciidoc for the writeup, can't be
//doing all this manually now can I?
//
//=== Research
//
//
//=== Planning
//
//
//=== Development
//
//
//=== Testing
//
//
//==== Writeup errors
//All the JSX commenting was JS style
//find `(.*\{\/\**.*)` replace with `$1*/}`
//to add end to all the // replaced with `{/*`
//
//path relative to file which imported it, not file which link originally in.

//include::test/test.adoc[]

include::api/index.adoc[]

== Bibliography

[bibliography]
- [[[JPQL]]] Oracle. JPQL Language Reference : https://docs.oracle.com/html/E13946_01/ejb3_langref.html . Accessed April 2018.
- [[[StackOverflow]]] Various. Many parts of the site : https://stackoverflow.com/ . Accessed 2018.
- [[[SpringBoot]]] Spring. SpringBoot 2.0.0 Reference : https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/ . Accessed April 2018
- [[[JavaDocs]]] Oracle. Java SE 8 docs : https://docs.oracle.com/javase/8/docs/ . Accessed April 2018
- [[[ReactTraining]]] ReactRouter. React Router Documentation : https://reacttraining.com/ . Accessed April 2018
- [[[ReactDocs]]] Facebook. React docs : https://reactjs.org/ . Accessed April 2018
- [[[AsciiDoctorPdf]]] Asciidoctor. AsciiDoctor pdf reference for writeup : https://asciidoctor.org/docs/asciidoctor-pdf/ . Accessed April 2018
